:trait _ParsedStructPointer
  :new _new(
    segments CapnProto.Segments
    segment CapnProto.Segment
    byte_offset U32
    data_word_count U16
    pointer_count U16
  )

:module _ParseStructPointer(A _ParsedStructPointer)
  :fun _parse!(segments, segment, current_offset U32, value U64)
    // Handle the case that this may be a far pointer, pointing to the pointer.
    override_byte_offset U32 = -1
    try (
      far = CapnProto.Pointer.Far._parse!(segments, segment, current_offset, value)
      segment = far._segment
      current_offset = far._byte_offset
      override_byte_offset = far._override_byte_offset
      value = far._pointer_value
    )

    // lsb                      struct pointer                       msb
    // +-+-----------------------------+---------------+---------------+
    // |A|             B               |       C       |       D       |
    // +-+-----------------------------+---------------+---------------+
    //
    // A (2 bits) = 0, to indicate that this is a struct pointer.
    // B (30 bits) = Offset, in words, from the end of the pointer to the
    //     start of the struct's data section.  Signed.
    // C (16 bits) = Size of the struct's data section, in words.
    // D (16 bits) = Size of the struct's pointer section, in words.

    // The 2 least significant bits (A) encode the pointer kind.
    // Raise an error if this is not coded as a struct pointer (kind zero).
    error! unless (value.u8.bit_and(0b11) == 0)

    // The bottom 32 bits of the value (excluding the 2 least significant bits)
    // encode a 30-bit signed integer (B) indicating the offset in 8-byte words
    // to the pointed-to location within the segment, from the current offset.
    //
    // Given that we know the lowest two bits are zero, we can treat this
    // as a 32-bit signed integer indicating half of the actual offset,
    // because multiplying by 4 is the same as bit shifting rightward by 2,
    // and 4 is half of the factor of 8 we need to mutiply by to translate
    // the offset from units of 8-byte words to units of bytes.
    //
    // We first truncate the U64 to a U32, then as a separate step,
    // we reinterpret the unsigned U32 as a signed I32.
    // When we add the signed offset half to the current offset, any overflow
    // or underflow is treated as a protocol error (an invalid pointer).
    offset_half = value.u32.i32
    byte_offset = (current_offset.i32 +! 8 +! offset_half +! offset_half).u32!
    if (override_byte_offset != -1) (byte_offset = override_byte_offset)

    // The two upper U16 parts of the value (C and D) indicate the size
    // of the struct's data section and its pointers section, in 8-byte words.
    // These allow us to calculate the pointers section offset and end offset.
    data_word_count = value.bit_shr(32).u16
    pointer_count = value.bit_shr(48).u16

    A._new(segments, segment, byte_offset, data_word_count, pointer_count)

:module _WriteStructPointer
  :fun _encode_with_zero_relative_offset(
    pointer CapnProto.Pointer.Struct.Builder
  )
    // lsb                      struct pointer                       msb
    // +-+-----------------------------+---------------+---------------+
    // |A|             B               |       C       |       D       |
    // +-+-----------------------------+---------------+---------------+
    //
    // A (2 bits) = 0, to indicate that this is a struct pointer.
    // B (30 bits) = Offset, in words, from the end of the pointer to the
    //     start of the struct's data section.  Signed.
    // C (16 bits) = Size of the struct's data section, in words.
    // D (16 bits) = Size of the struct's pointer section, in words.
    pointer._data_word_count.u64.bit_shl(32)           // C
      .bit_or(pointer._pointer_count.u64.bit_shl(48)) // D (A and B are zero)

:struct CapnProto.Pointer.Struct
  :let _segments CapnProto.Segments
  :let _segment CapnProto.Segment
  :let _byte_offset U32
  :let _data_word_count U16
  :let _pointer_count U16
  :new _new(
    @_segments, @_segment, @_byte_offset, @_data_word_count, @_pointer_count
  )

  :new empty(@_segments, @_segment)
    @_byte_offset = 0
    @_data_word_count = 0
    @_pointer_count = 0

  :fun non from_segments!(
    segments CapnProto.Segments
    start_offset USize = 0
    segment_index USize = 0
  )
    segment = segments._list[segment_index]!
    value = segment._u64!(start_offset.u32)
    _ParseStructPointer(CapnProto.Pointer.Struct)._parse!(
      segments, segment, start_offset.u32, value
    )

  :fun _ptr_byte_offset!(n U16)
    error! unless (@_pointer_count > n)
    @_byte_offset +! (@_data_word_count +! n).u32 * 8

  :fun _u8!(n U32)
    error! unless (@_data_word_count.u32 * 8 > n)
    @_segment._u8!(@_byte_offset +! n)

  :fun _u16!(n U32)
    error! unless (@_data_word_count.u32 * 8 > n)
    @_segment._u16!(@_byte_offset +! n)

  :fun _u32!(n U32)
    error! unless (@_data_word_count.u32 * 8 > n)
    @_segment._u32!(@_byte_offset +! n)

  :fun _u64!(n U32)
    error! unless (@_data_word_count.u32 * 8 > n)
    @_segment._u64!(@_byte_offset +! n)

  :fun ref _set_u8!(n U32, v U8)
    error! unless (@_data_word_count.u32 * 8 > n)
    @_segment._set_u8!(@_byte_offset +! n, v)

  :fun ref _set_u16!(n U32, v U16)
    error! unless (@_data_word_count.u32 * 8 > n)
    @_segment._set_u16!(@_byte_offset +! n, v)

  :fun ref _set_u32!(n U32, v U32)
    error! unless (@_data_word_count.u32 * 8 > n)
    @_segment._set_u32!(@_byte_offset +! n, v)

  :fun ref _set_u64!(n U32, v U64)
    error! unless (@_data_word_count.u32 * 8 > n)
    @_segment._set_u64!(@_byte_offset +! n, v)

  :fun u8(n) U8: try (@_u8!(n) | 0)
  :fun u16(n) U16: try (@_u16!(n) | 0)
  :fun u32(n) U32: try (@_u32!(n) | 0)
  :fun u64(n) U64: try (@_u64!(n) | 0)

  :fun i8(n): @u8(n).i8
  :fun i16(n): @u16(n).i16
  :fun i32(n): @u32(n).i32
  :fun i64(n): @u64(n).i64

  :fun f32(n): @u32(n).f32
  :fun f64(n): @u64(n).f64

  :fun bool(n, bit_mask): @u8(n).bit_and(bit_mask) != 0

  :fun assert_union!(n, value): error! if (@u16(n) != value)
  :fun check_union(n, value): @u16(n) == value

  // TODO: Deal with the ref/val/box possibilities here instead of assuming ref
  :fun ref text(n): try (@_text!(n) | @_empty_text)
  :fun ref _empty_text
    CapnProto.Text.from_pointer(
      CapnProto.Pointer.U8List.empty(@_segments, @_segment)
    )
  :fun ref _text!(n)
    byte_offset = @_ptr_byte_offset!(n)
    CapnProto.Text._parse!(
      @_segments, @_segment, byte_offset, @_segment._u64!(byte_offset)
    )

  // TODO: Deal with the ref/val/box possibilities here instead of assuming ref
  :fun ref data(n): try (@_data!(n) | @_empty_data)
  :fun ref _empty_data
    CapnProto.Data.from_pointer(CapnProto.Pointer.U8List.empty(@_segments, @_segment))
  :fun ref _data!(n)
    byte_offset = @_ptr_byte_offset!(n)
    CapnProto.Data._parse!(
      @_segments, @_segment, byte_offset, @_segment._u64!(byte_offset)
    )

  // TODO: Deal with the ref/val/box possibilities here instead of assuming ref
  :fun ref struct(n): try (@_struct!(n) | @_empty_struct)
  :fun ref _empty_struct
    CapnProto.Pointer.Struct.empty(@_segments, @_segment)
  :fun ref _struct!(n):
    byte_offset = @_ptr_byte_offset!(n)
    _ParseStructPointer(CapnProto.Pointer.Struct)._parse!(
      @_segments, @_segment, byte_offset, @_segment._u64!(byte_offset)
    )

  // TODO: Deal with the ref/val/box possibilities here instead of assuming ref
  :fun ref list(n): try (@_list!(n) | @_empty_list)
  :fun ref _empty_list
    CapnProto.Pointer.StructList.empty(@_segments, @_segment)
  :fun ref _list!(n):
    byte_offset = @_ptr_byte_offset!(n)
    _ParseStructListPointer(CapnProto.Pointer.StructList)._parse!(
      @_segments, @_segment, byte_offset, @_segment._u64!(byte_offset)
    )

:struct CapnProto.Pointer.Struct.Builder
  :let _segments CapnProto.Segments
  :let _segment CapnProto.Segment
  :let _byte_offset U32
  :let _data_word_count U16
  :let _pointer_count U16
  :new _new(
    @_segments, @_segment, @_byte_offset, @_data_word_count, @_pointer_count
  )

  :new empty(@_segments, @_segment)
    @_byte_offset = 0
    @_data_word_count = 0
    @_pointer_count = 0

  :fun non from_segments!(
    segments CapnProto.Segments
    start_offset USize = 0
    segment_index USize = 0
  )
    segment = segments._list[segment_index]!
    value = segment._u64!(start_offset.u32)
    _ParseStructPointer(CapnProto.Pointer.Struct)._parse!(
      segments, segment, start_offset.u32, value
    )

  :fun _ptr_byte_offset!(n U16)
    error! unless (@_pointer_count > n)
    @_byte_offset +! (@_data_word_count +! n).u32 * 8

  :fun _u8!(n U32)
    error! unless (@_data_word_count.u32 * 8 > n)
    @_segment._u8!(@_byte_offset +! n)

  :fun _u16!(n U32)
    error! unless (@_data_word_count.u32 * 8 > n)
    @_segment._u16!(@_byte_offset +! n)

  :fun _u32!(n U32)
    error! unless (@_data_word_count.u32 * 8 > n)
    @_segment._u32!(@_byte_offset +! n)

  :fun _u64!(n U32)
    error! unless (@_data_word_count.u32 * 8 > n)
    @_segment._u64!(@_byte_offset +! n)

  :fun ref _set_u8!(n U32, v U8)
    error! unless (@_data_word_count.u32 * 8 > n)
    @_segment._set_u8!(@_byte_offset +! n, v)

  :fun ref _set_u16!(n U32, v U16)
    error! unless (@_data_word_count.u32 * 8 > n)
    @_segment._set_u16!(@_byte_offset +! n, v)

  :fun ref _set_u32!(n U32, v U32)
    error! unless (@_data_word_count.u32 * 8 > n)
    @_segment._set_u32!(@_byte_offset +! n, v)

  :fun ref _set_u64!(n U32, v U64)
    error! unless (@_data_word_count.u32 * 8 > n)
    @_segment._set_u64!(@_byte_offset +! n, v)

  :fun u8(n) U8: try (@_u8!(n) | 0)
  :fun u16(n) U16: try (@_u16!(n) | 0)
  :fun u32(n) U32: try (@_u32!(n) | 0)
  :fun u64(n) U64: try (@_u64!(n) | 0)

  :fun i8(n): @u8(n).i8
  :fun i16(n): @u16(n).i16
  :fun i32(n): @u32(n).i32
  :fun i64(n): @u64(n).i64

  :fun f32(n): @u32(n).f32
  :fun f64(n): @u64(n).f64

  :fun bool(n, bit_mask): @u8(n).bit_and(bit_mask) != 0

  :fun ref set_u8(n, v U8, d U8): try @_set_u8!(n, v.bit_xor(d)), v
  :fun ref set_u16(n, v U16, d U16): try @_set_u16!(n, v.bit_xor(d)), v
  :fun ref set_u32(n, v U32, d U32): try @_set_u32!(n, v.bit_xor(d)), v
  :fun ref set_u64(n, v U64, d U64): try @_set_u64!(n, v.bit_xor(d)), v

  :fun ref set_i8(n, v I8, d I8): @set_u8(n, v.u8, d.u8), v
  :fun ref set_i16(n, v I16, d I16): @set_u16(n, v.u16, d.u16), v
  :fun ref set_i32(n, v I32, d I32): @set_u32(n, v.u32, d.u32), v
  :fun ref set_i64(n, v I64, d I64): @set_u64(n, v.u64, d.u64), v

  :fun ref set_f32(n, v F32, d F32): @set_u32(n, v.u32, d.u32), v
  :fun ref set_f64(n, v F64, d F64): @set_u64(n, v.u64, d.u64), v

  :fun ref set_bool(n, bit_mask, value Bool)
    if value (
      @set_u8(n, @u8(n).bit_or(bit_mask), 0)
    |
      @set_u8(n, @u8(n).bit_and(bit_mask.invert), 0)
    )
    value

  :fun assert_union!(n, value): error! if (@u16(n) != value)
  :fun check_union(n, value): @u16(n) == value

  // TODO: Deal with the ref/val/box possibilities here instead of assuming ref
  :fun ref text(n): try (@_text!(n) | @_empty_text)
  :fun ref _empty_text
    CapnProto.Text.from_pointer(
      CapnProto.Pointer.U8List.empty(@_segments, @_segment)
    )
  :fun ref _text!(n)
    byte_offset = @_ptr_byte_offset!(n)
    CapnProto.Text._parse!(
      @_segments, @_segment, byte_offset, @_segment._u64!(byte_offset)
    )

  :fun ref set_text(n, value String, default_value String) CapnProto.Text
    // TODO: account for default_value

    // We expect the byte offset to be within bounds - otherwise we can't do it,
    // and we'll return an empty `CapnProto.Text` to signal this problem.
    byte_offset = try (@_ptr_byte_offset!(n) | return @_empty_text)

    // If there's an existing text pointer, we can free it now.
    try CapnProto.Text._parse!(
      @_segments, @_segment, byte_offset, @_segment._u64!(byte_offset)
    )._p._free

    // If the requested value is empty, we won't allocate anything new.
    // We'll just write zero bytes to that pointer's position and return.
    if value.is_empty (
      try @_segment._set_u64!(byte_offset, 0)
      return @_empty_text
    )

    // Now we allocate the new one.
    new_text = CapnProto.Text._new(@_segments, @_segment, value)

    // We need to write the pointer to the buffer so it can be followed.
    try @_segment._set_u64!(
      byte_offset
      _WriteU8ListPointer._encode(byte_offset, new_text._p)
    )

    new_text

  // TODO: Deal with the ref/val/box possibilities here instead of assuming ref
  :fun ref data(n): try (@_data!(n) | @_empty_data)
  :fun ref _empty_data
    CapnProto.Data.from_pointer(CapnProto.Pointer.U8List.empty(@_segments, @_segment))
  :fun ref _data!(n)
    byte_offset = @_ptr_byte_offset!(n)
    CapnProto.Data._parse!(
      @_segments, @_segment, byte_offset, @_segment._u64!(byte_offset)
    )

  :fun ref set_data(n, value Bytes, default_value Bytes) CapnProto.Data
    // TODO: account for default_value

    // We expect the byte offset to be within bounds - otherwise we can't do it,
    // and we'll return an empty `CapnProto.Data` to signal this problem.
    byte_offset = try (@_ptr_byte_offset!(n) | return @_empty_data)

    // If there's an existing data pointer, we can free it now.
    try CapnProto.Data._parse!(
      @_segments, @_segment, byte_offset, @_segment._u64!(byte_offset)
    )._p._free

    // If the requested value is empty, we won't allocate anything new.
    // We'll just write zero bytes to that pointer's position and return.
    if value.is_empty (
      try @_segment._set_u64!(byte_offset, 0)
      return @_empty_data
    )

    // Now we allocate the new one.
    new_data = CapnProto.Data._new(@_segments, @_segment, value)

    // We need to write the pointer to the buffer so it can be followed.
    try @_segment._set_u64!(
      byte_offset
      _WriteU8ListPointer._encode(byte_offset, new_data._p)
    )

    new_data

  // TODO: Deal with the ref/val/box possibilities here instead of assuming ref
  :fun ref struct(n): try (@_struct!(n) | @_empty_struct)
  :fun ref _empty_struct
    CapnProto.Pointer.Struct.Builder.empty(@_segments, @_segment)
  :fun ref _struct!(n):
    byte_offset = @_ptr_byte_offset!(n)
    _ParseStructPointer(CapnProto.Pointer.Struct.Builder)._parse!(
      @_segments, @_segment, byte_offset, @_segment._u64!(byte_offset)
    )

  // TODO: Deal with the ref/val/box possibilities here instead of assuming ref
  :fun ref list(n): try (@_list!(n) | @_empty_list)
  :fun ref _empty_list
    CapnProto.Pointer.StructList.Builder.empty(@_segments, @_segment)
  :fun ref _list!(n):
    byte_offset = @_ptr_byte_offset!(n)
    _ParseStructListPointer(CapnProto.Pointer.StructList.Builder)._parse!(
      @_segments, @_segment, byte_offset, @_segment._u64!(byte_offset)
    )

  :fun ref init_list(
    n U16
    data_word_count U16
    pointer_count U16
    new_list_count U32
  ) CapnProto.Pointer.StructList.Builder
    // We expect the byte offset to be within bounds - otherwise we can't do it,
    // and we'll return an empty `CapnProto.Data` to signal this problem.
    byte_offset = try (@_ptr_byte_offset!(n) | return @_empty_list)

    // If there's an existing list pointer, we can free it now.
    try _ParseStructListPointer(CapnProto.Pointer.StructList.Builder)._parse!(
      @_segments, @_segment, byte_offset, @_segment._u64!(byte_offset)
    )._free

    // If the requested count is empty, we won't allocate anything new.
    // We'll just write zero bytes to that pointer's position and return.
    if new_list_count.is_zero (
      try @_segment._set_u64!(byte_offset, 0)
      return @_empty_list
    )

    // Now we allocate the new one.
    new_pointer = CapnProto.Pointer.StructList.Builder._allocate(
      @_segments, @_segment
      new_list_count, data_word_count, pointer_count
    )

    // We need to write the pointer to the buffer so it can be followed.
    try @_segment._set_u64!(
      byte_offset
      _WriteStructListPointer._encode(byte_offset, new_pointer)
    )

    new_pointer
