///
// NOTE: This file was auto-generated from a Cap'n Proto file
// using the `capnp` compiler with the `--output=savi` option.

:struct box CapnProto.Meta.Node
  :let _p CapnProto.Pointer.Struct
  :new box read_from_pointer(@_p)

  :const capn_proto_data_word_count U16: 5
  :const capn_proto_pointer_count U16: 6

  :is TraceData
  :fun trace_data(trace TraceData.Observer)
    trace.object(@_p.absolute_address) -> (
      try trace.property("id", @id_if_set!)
      try trace.property("display_name", @display_name_if_set!)
      try trace.property("display_name_prefix_length", @display_name_prefix_length_if_set!)
      try trace.property("scope_id", @scope_id_if_set!)
      try trace.property("nested_nodes", @nested_nodes_if_set!)
      try trace.property("annotations", @annotations_if_set!)
      try trace.property("file", @file!)
      try trace.property("struct", @struct!)
      try trace.property("enum", @enum!)
      try trace.property("interface", @interface!)
      try trace.property("const", @const!)
      try trace.property("annotation", @annotation!)
      try trace.property("parameters", @parameters_if_set!)
      try trace.property("is_generic", @is_generic_if_set!)
    )

  :fun id: @_p.u64(0x0)
  :fun id_if_set!: @_p.u64_if_set!(0x0)

  :fun display_name: @_p.text(0)
  :fun display_name_if_set!: @_p.text_if_set!(0)

  :fun display_name_prefix_length: @_p.u32(0x8)
  :fun display_name_prefix_length_if_set!: @_p.u32_if_set!(0x8)

  :fun scope_id: @_p.u64(0x10)
  :fun scope_id_if_set!: @_p.u64_if_set!(0x10)

  :fun nested_nodes: CapnProto.List(CapnProto.Meta.Node.NestedNode).read_from_pointer(@_p.list(1))
  :fun nested_nodes_if_set!: CapnProto.List(CapnProto.Meta.Node.NestedNode).read_from_pointer(@_p.list_if_set!(1))

  :fun annotations: CapnProto.List(CapnProto.Meta.Annotation).read_from_pointer(@_p.list(2))
  :fun annotations_if_set!: CapnProto.List(CapnProto.Meta.Annotation).read_from_pointer(@_p.list_if_set!(2))

  :fun is_file: @_p.check_union(0xc, 0)
  :fun file!: @_p.assert_union!(0xc, 0), None
  :fun file_if_set!: @_p.assert_union!(0xc, 0), None

  :fun is_struct: @_p.check_union(0xc, 1)
  :fun struct!: @_p.assert_union!(0xc, 1), CapnProto.Meta.Node.AS_struct.read_from_pointer(@_p)
  :fun struct_if_set!: @_p.assert_union!(0xc, 1), CapnProto.Meta.Node.AS_struct.read_from_pointer(@_p)

  :fun is_enum: @_p.check_union(0xc, 2)
  :fun enum!: @_p.assert_union!(0xc, 2), CapnProto.Meta.Node.AS_enum.read_from_pointer(@_p)
  :fun enum_if_set!: @_p.assert_union!(0xc, 2), CapnProto.Meta.Node.AS_enum.read_from_pointer(@_p)

  :fun is_interface: @_p.check_union(0xc, 3)
  :fun interface!: @_p.assert_union!(0xc, 3), CapnProto.Meta.Node.AS_interface.read_from_pointer(@_p)
  :fun interface_if_set!: @_p.assert_union!(0xc, 3), CapnProto.Meta.Node.AS_interface.read_from_pointer(@_p)

  :fun is_const: @_p.check_union(0xc, 4)
  :fun const!: @_p.assert_union!(0xc, 4), CapnProto.Meta.Node.AS_const.read_from_pointer(@_p)
  :fun const_if_set!: @_p.assert_union!(0xc, 4), CapnProto.Meta.Node.AS_const.read_from_pointer(@_p)

  :fun is_annotation: @_p.check_union(0xc, 5)
  :fun annotation!: @_p.assert_union!(0xc, 5), CapnProto.Meta.Node.AS_annotation.read_from_pointer(@_p)
  :fun annotation_if_set!: @_p.assert_union!(0xc, 5), CapnProto.Meta.Node.AS_annotation.read_from_pointer(@_p)

  :fun parameters: CapnProto.List(CapnProto.Meta.Node.Parameter).read_from_pointer(@_p.list(5))
  :fun parameters_if_set!: CapnProto.List(CapnProto.Meta.Node.Parameter).read_from_pointer(@_p.list_if_set!(5))

  :fun is_generic: @_p.bool(0x24, 0b00000001)
  :fun is_generic_if_set!: @_p.bool_if_set!(0x24, 0b00000001)

:struct box CapnProto.Meta.Node.AS_struct
  :let _p CapnProto.Pointer.Struct
  :new box read_from_pointer(@_p)

  :const capn_proto_data_word_count U16: 5
  :const capn_proto_pointer_count U16: 6

  :is TraceData
  :fun trace_data(trace TraceData.Observer)
    trace.object(0) -> (
      try trace.property("data_word_count", @data_word_count_if_set!)
      try trace.property("pointer_count", @pointer_count_if_set!)
      try trace.property("preferred_list_encoding", @preferred_list_encoding_if_set!)
      try trace.property("is_group", @is_group_if_set!)
      try trace.property("discriminant_count", @discriminant_count_if_set!)
      try trace.property("discriminant_offset", @discriminant_offset_if_set!)
      try trace.property("fields", @fields_if_set!)
    )

  :fun data_word_count: @_p.u16(0xe)
  :fun data_word_count_if_set!: @_p.u16_if_set!(0xe)

  :fun pointer_count: @_p.u16(0x18)
  :fun pointer_count_if_set!: @_p.u16_if_set!(0x18)

  :fun preferred_list_encoding: CapnProto.Meta.ElementSize._new(@_p.u16(0x1a))
  :fun preferred_list_encoding_if_set!: CapnProto.Meta.ElementSize._new(@_p.u16_if_set!(0x1a))

  :fun is_group: @_p.bool(0x1c, 0b00000001)
  :fun is_group_if_set!: @_p.bool_if_set!(0x1c, 0b00000001)

  :fun discriminant_count: @_p.u16(0x1e)
  :fun discriminant_count_if_set!: @_p.u16_if_set!(0x1e)

  :fun discriminant_offset: @_p.u32(0x20)
  :fun discriminant_offset_if_set!: @_p.u32_if_set!(0x20)

  :fun fields: CapnProto.List(CapnProto.Meta.Field).read_from_pointer(@_p.list(3))
  :fun fields_if_set!: CapnProto.List(CapnProto.Meta.Field).read_from_pointer(@_p.list_if_set!(3))

:struct box CapnProto.Meta.Node.AS_enum
  :let _p CapnProto.Pointer.Struct
  :new box read_from_pointer(@_p)

  :const capn_proto_data_word_count U16: 5
  :const capn_proto_pointer_count U16: 6

  :is TraceData
  :fun trace_data(trace TraceData.Observer)
    trace.object(0) -> (
      try trace.property("enumerants", @enumerants_if_set!)
    )

  :fun enumerants: CapnProto.List(CapnProto.Meta.Enumerant).read_from_pointer(@_p.list(3))
  :fun enumerants_if_set!: CapnProto.List(CapnProto.Meta.Enumerant).read_from_pointer(@_p.list_if_set!(3))

:struct box CapnProto.Meta.Node.AS_interface
  :let _p CapnProto.Pointer.Struct
  :new box read_from_pointer(@_p)

  :const capn_proto_data_word_count U16: 5
  :const capn_proto_pointer_count U16: 6

  :is TraceData
  :fun trace_data(trace TraceData.Observer)
    trace.object(0) -> (
      try trace.property("methods", @methods_if_set!)
      try trace.property("superclasses", @superclasses_if_set!)
    )

  :fun methods: CapnProto.List(CapnProto.Meta.Method).read_from_pointer(@_p.list(3))
  :fun methods_if_set!: CapnProto.List(CapnProto.Meta.Method).read_from_pointer(@_p.list_if_set!(3))

  :fun superclasses: CapnProto.List(CapnProto.Meta.Superclass).read_from_pointer(@_p.list(4))
  :fun superclasses_if_set!: CapnProto.List(CapnProto.Meta.Superclass).read_from_pointer(@_p.list_if_set!(4))

:struct box CapnProto.Meta.Node.AS_const
  :let _p CapnProto.Pointer.Struct
  :new box read_from_pointer(@_p)

  :const capn_proto_data_word_count U16: 5
  :const capn_proto_pointer_count U16: 6

  :is TraceData
  :fun trace_data(trace TraceData.Observer)
    trace.object(0) -> (
      try trace.property("type", @type_if_set!)
      try trace.property("value", @value_if_set!)
    )

  :fun type: CapnProto.Meta.Type.read_from_pointer(@_p.struct(3))
  :fun type_if_set!: CapnProto.Meta.Type.read_from_pointer(@_p.struct_if_set!(3))

  :fun value: CapnProto.Meta.Value.read_from_pointer(@_p.struct(4))
  :fun value_if_set!: CapnProto.Meta.Value.read_from_pointer(@_p.struct_if_set!(4))

:struct box CapnProto.Meta.Node.AS_annotation
  :let _p CapnProto.Pointer.Struct
  :new box read_from_pointer(@_p)

  :const capn_proto_data_word_count U16: 5
  :const capn_proto_pointer_count U16: 6

  :is TraceData
  :fun trace_data(trace TraceData.Observer)
    trace.object(0) -> (
      try trace.property("type", @type_if_set!)
      try trace.property("targets_file", @targets_file_if_set!)
      try trace.property("targets_const", @targets_const_if_set!)
      try trace.property("targets_enum", @targets_enum_if_set!)
      try trace.property("targets_enumerant", @targets_enumerant_if_set!)
      try trace.property("targets_struct", @targets_struct_if_set!)
      try trace.property("targets_field", @targets_field_if_set!)
      try trace.property("targets_union", @targets_union_if_set!)
      try trace.property("targets_group", @targets_group_if_set!)
      try trace.property("targets_interface", @targets_interface_if_set!)
      try trace.property("targets_method", @targets_method_if_set!)
      try trace.property("targets_param", @targets_param_if_set!)
      try trace.property("targets_annotation", @targets_annotation_if_set!)
    )

  :fun type: CapnProto.Meta.Type.read_from_pointer(@_p.struct(3))
  :fun type_if_set!: CapnProto.Meta.Type.read_from_pointer(@_p.struct_if_set!(3))

  :fun targets_file: @_p.bool(0xe, 0b00000001)
  :fun targets_file_if_set!: @_p.bool_if_set!(0xe, 0b00000001)

  :fun targets_const: @_p.bool(0xe, 0b00000010)
  :fun targets_const_if_set!: @_p.bool_if_set!(0xe, 0b00000010)

  :fun targets_enum: @_p.bool(0xe, 0b00000100)
  :fun targets_enum_if_set!: @_p.bool_if_set!(0xe, 0b00000100)

  :fun targets_enumerant: @_p.bool(0xe, 0b00001000)
  :fun targets_enumerant_if_set!: @_p.bool_if_set!(0xe, 0b00001000)

  :fun targets_struct: @_p.bool(0xe, 0b00010000)
  :fun targets_struct_if_set!: @_p.bool_if_set!(0xe, 0b00010000)

  :fun targets_field: @_p.bool(0xe, 0b00100000)
  :fun targets_field_if_set!: @_p.bool_if_set!(0xe, 0b00100000)

  :fun targets_union: @_p.bool(0xe, 0b01000000)
  :fun targets_union_if_set!: @_p.bool_if_set!(0xe, 0b01000000)

  :fun targets_group: @_p.bool(0xe, 0b10000000)
  :fun targets_group_if_set!: @_p.bool_if_set!(0xe, 0b10000000)

  :fun targets_interface: @_p.bool(0xf, 0b00000001)
  :fun targets_interface_if_set!: @_p.bool_if_set!(0xf, 0b00000001)

  :fun targets_method: @_p.bool(0xf, 0b00000010)
  :fun targets_method_if_set!: @_p.bool_if_set!(0xf, 0b00000010)

  :fun targets_param: @_p.bool(0xf, 0b00000100)
  :fun targets_param_if_set!: @_p.bool_if_set!(0xf, 0b00000100)

  :fun targets_annotation: @_p.bool(0xf, 0b00001000)
  :fun targets_annotation_if_set!: @_p.bool_if_set!(0xf, 0b00001000)

:struct box CapnProto.Meta.Node.Parameter
  :let _p CapnProto.Pointer.Struct
  :new box read_from_pointer(@_p)

  :const capn_proto_data_word_count U16: 0
  :const capn_proto_pointer_count U16: 1

  :is TraceData
  :fun trace_data(trace TraceData.Observer)
    trace.object(@_p.absolute_address) -> (
      try trace.property("name", @name_if_set!)
    )

  :fun name: @_p.text(0)
  :fun name_if_set!: @_p.text_if_set!(0)

:struct box CapnProto.Meta.Node.NestedNode
  :let _p CapnProto.Pointer.Struct
  :new box read_from_pointer(@_p)

  :const capn_proto_data_word_count U16: 1
  :const capn_proto_pointer_count U16: 1

  :is TraceData
  :fun trace_data(trace TraceData.Observer)
    trace.object(@_p.absolute_address) -> (
      try trace.property("name", @name_if_set!)
      try trace.property("id", @id_if_set!)
    )

  :fun name: @_p.text(0)
  :fun name_if_set!: @_p.text_if_set!(0)

  :fun id: @_p.u64(0x0)
  :fun id_if_set!: @_p.u64_if_set!(0x0)

:struct box CapnProto.Meta.Field
  :let _p CapnProto.Pointer.Struct
  :new box read_from_pointer(@_p)

  :const capn_proto_data_word_count U16: 3
  :const capn_proto_pointer_count U16: 4

  :const no_discriminant U16: 65535

  :is TraceData
  :fun trace_data(trace TraceData.Observer)
    trace.object(@_p.absolute_address) -> (
      try trace.property("name", @name_if_set!)
      try trace.property("code_order", @code_order_if_set!)
      try trace.property("annotations", @annotations_if_set!)
      try trace.property("discriminant_value", @discriminant_value_if_set!)
      try trace.property("slot", @slot!)
      try trace.property("group", @group!)
      try trace.property("ordinal", @ordinal_if_set!)
    )

  :fun name: @_p.text(0)
  :fun name_if_set!: @_p.text_if_set!(0)

  :fun code_order: @_p.u16(0x0)
  :fun code_order_if_set!: @_p.u16_if_set!(0x0)

  :fun annotations: CapnProto.List(CapnProto.Meta.Annotation).read_from_pointer(@_p.list(1))
  :fun annotations_if_set!: CapnProto.List(CapnProto.Meta.Annotation).read_from_pointer(@_p.list_if_set!(1))

  :fun discriminant_value: @_p.u16(0x2).bit_xor(65535)
  :fun discriminant_value_if_set!: @_p.u16_if_set!(0x2).bit_xor(65535)

  :fun is_slot: @_p.check_union(0x8, 0)
  :fun slot!: @_p.assert_union!(0x8, 0), CapnProto.Meta.Field.AS_slot.read_from_pointer(@_p)
  :fun slot_if_set!: @_p.assert_union!(0x8, 0), CapnProto.Meta.Field.AS_slot.read_from_pointer(@_p)

  :fun is_group: @_p.check_union(0x8, 1)
  :fun group!: @_p.assert_union!(0x8, 1), CapnProto.Meta.Field.AS_group.read_from_pointer(@_p)
  :fun group_if_set!: @_p.assert_union!(0x8, 1), CapnProto.Meta.Field.AS_group.read_from_pointer(@_p)

  :fun ordinal: CapnProto.Meta.Field.AS_ordinal.read_from_pointer(@_p)
  :fun ordinal_if_set!: CapnProto.Meta.Field.AS_ordinal.read_from_pointer(@_p)

:struct box CapnProto.Meta.Field.AS_slot
  :let _p CapnProto.Pointer.Struct
  :new box read_from_pointer(@_p)

  :const capn_proto_data_word_count U16: 3
  :const capn_proto_pointer_count U16: 4

  :is TraceData
  :fun trace_data(trace TraceData.Observer)
    trace.object(0) -> (
      try trace.property("offset", @offset_if_set!)
      try trace.property("type", @type_if_set!)
      try trace.property("default_value", @default_value_if_set!)
      try trace.property("had_explicit_default", @had_explicit_default_if_set!)
    )

  :fun offset: @_p.u32(0x4)
  :fun offset_if_set!: @_p.u32_if_set!(0x4)

  :fun type: CapnProto.Meta.Type.read_from_pointer(@_p.struct(2))
  :fun type_if_set!: CapnProto.Meta.Type.read_from_pointer(@_p.struct_if_set!(2))

  :fun default_value: CapnProto.Meta.Value.read_from_pointer(@_p.struct(3))
  :fun default_value_if_set!: CapnProto.Meta.Value.read_from_pointer(@_p.struct_if_set!(3))

  :fun had_explicit_default: @_p.bool(0x10, 0b00000001)
  :fun had_explicit_default_if_set!: @_p.bool_if_set!(0x10, 0b00000001)

:struct box CapnProto.Meta.Field.AS_group
  :let _p CapnProto.Pointer.Struct
  :new box read_from_pointer(@_p)

  :const capn_proto_data_word_count U16: 3
  :const capn_proto_pointer_count U16: 4

  :is TraceData
  :fun trace_data(trace TraceData.Observer)
    trace.object(0) -> (
      try trace.property("type_id", @type_id_if_set!)
    )

  :fun type_id: @_p.u64(0x10)
  :fun type_id_if_set!: @_p.u64_if_set!(0x10)

:struct box CapnProto.Meta.Field.AS_ordinal
  :let _p CapnProto.Pointer.Struct
  :new box read_from_pointer(@_p)

  :const capn_proto_data_word_count U16: 3
  :const capn_proto_pointer_count U16: 4

  :is TraceData
  :fun trace_data(trace TraceData.Observer)
    trace.object(0) -> (
      try trace.property("implicit", @implicit!)
      try trace.property("explicit", @explicit!)
    )

  :fun is_implicit: @_p.check_union(0xa, 0)
  :fun implicit!: @_p.assert_union!(0xa, 0), None
  :fun implicit_if_set!: @_p.assert_union!(0xa, 0), None

  :fun is_explicit: @_p.check_union(0xa, 1)
  :fun explicit!: @_p.assert_union!(0xa, 1), @_p.u16(0xc)
  :fun explicit_if_set!: @_p.assert_union!(0xa, 1), @_p.u16_if_set!(0xc)

:struct box CapnProto.Meta.Enumerant
  :let _p CapnProto.Pointer.Struct
  :new box read_from_pointer(@_p)

  :const capn_proto_data_word_count U16: 1
  :const capn_proto_pointer_count U16: 2

  :is TraceData
  :fun trace_data(trace TraceData.Observer)
    trace.object(@_p.absolute_address) -> (
      try trace.property("name", @name_if_set!)
      try trace.property("code_order", @code_order_if_set!)
      try trace.property("annotations", @annotations_if_set!)
    )

  :fun name: @_p.text(0)
  :fun name_if_set!: @_p.text_if_set!(0)

  :fun code_order: @_p.u16(0x0)
  :fun code_order_if_set!: @_p.u16_if_set!(0x0)

  :fun annotations: CapnProto.List(CapnProto.Meta.Annotation).read_from_pointer(@_p.list(1))
  :fun annotations_if_set!: CapnProto.List(CapnProto.Meta.Annotation).read_from_pointer(@_p.list_if_set!(1))

:struct box CapnProto.Meta.Superclass
  :let _p CapnProto.Pointer.Struct
  :new box read_from_pointer(@_p)

  :const capn_proto_data_word_count U16: 1
  :const capn_proto_pointer_count U16: 1

  :is TraceData
  :fun trace_data(trace TraceData.Observer)
    trace.object(@_p.absolute_address) -> (
      try trace.property("id", @id_if_set!)
      try trace.property("brand", @brand_if_set!)
    )

  :fun id: @_p.u64(0x0)
  :fun id_if_set!: @_p.u64_if_set!(0x0)

  :fun brand: CapnProto.Meta.Brand.read_from_pointer(@_p.struct(0))
  :fun brand_if_set!: CapnProto.Meta.Brand.read_from_pointer(@_p.struct_if_set!(0))

:struct box CapnProto.Meta.Method
  :let _p CapnProto.Pointer.Struct
  :new box read_from_pointer(@_p)

  :const capn_proto_data_word_count U16: 3
  :const capn_proto_pointer_count U16: 5

  :is TraceData
  :fun trace_data(trace TraceData.Observer)
    trace.object(@_p.absolute_address) -> (
      try trace.property("name", @name_if_set!)
      try trace.property("code_order", @code_order_if_set!)
      try trace.property("param_struct_type", @param_struct_type_if_set!)
      try trace.property("result_struct_type", @result_struct_type_if_set!)
      try trace.property("annotations", @annotations_if_set!)
      try trace.property("param_brand", @param_brand_if_set!)
      try trace.property("result_brand", @result_brand_if_set!)
      try trace.property("implicit_parameters", @implicit_parameters_if_set!)
    )

  :fun name: @_p.text(0)
  :fun name_if_set!: @_p.text_if_set!(0)

  :fun code_order: @_p.u16(0x0)
  :fun code_order_if_set!: @_p.u16_if_set!(0x0)

  :fun param_struct_type: @_p.u64(0x8)
  :fun param_struct_type_if_set!: @_p.u64_if_set!(0x8)

  :fun result_struct_type: @_p.u64(0x10)
  :fun result_struct_type_if_set!: @_p.u64_if_set!(0x10)

  :fun annotations: CapnProto.List(CapnProto.Meta.Annotation).read_from_pointer(@_p.list(1))
  :fun annotations_if_set!: CapnProto.List(CapnProto.Meta.Annotation).read_from_pointer(@_p.list_if_set!(1))

  :fun param_brand: CapnProto.Meta.Brand.read_from_pointer(@_p.struct(2))
  :fun param_brand_if_set!: CapnProto.Meta.Brand.read_from_pointer(@_p.struct_if_set!(2))

  :fun result_brand: CapnProto.Meta.Brand.read_from_pointer(@_p.struct(3))
  :fun result_brand_if_set!: CapnProto.Meta.Brand.read_from_pointer(@_p.struct_if_set!(3))

  :fun implicit_parameters: CapnProto.List(CapnProto.Meta.Node.Parameter).read_from_pointer(@_p.list(4))
  :fun implicit_parameters_if_set!: CapnProto.List(CapnProto.Meta.Node.Parameter).read_from_pointer(@_p.list_if_set!(4))

:struct box CapnProto.Meta.Type
  :let _p CapnProto.Pointer.Struct
  :new box read_from_pointer(@_p)

  :const capn_proto_data_word_count U16: 3
  :const capn_proto_pointer_count U16: 1

  :is TraceData
  :fun trace_data(trace TraceData.Observer)
    trace.object(@_p.absolute_address) -> (
      try trace.property("void", @void!)
      try trace.property("bool", @bool!)
      try trace.property("int8", @int8!)
      try trace.property("int16", @int16!)
      try trace.property("int32", @int32!)
      try trace.property("int64", @int64!)
      try trace.property("uint8", @uint8!)
      try trace.property("uint16", @uint16!)
      try trace.property("uint32", @uint32!)
      try trace.property("uint64", @uint64!)
      try trace.property("float32", @float32!)
      try trace.property("float64", @float64!)
      try trace.property("text", @text!)
      try trace.property("data", @data!)
      try trace.property("list", @list!)
      try trace.property("enum", @enum!)
      try trace.property("struct", @struct!)
      try trace.property("interface", @interface!)
      try trace.property("any_pointer", @any_pointer!)
    )

  :fun is_void: @_p.check_union(0x0, 0)
  :fun void!: @_p.assert_union!(0x0, 0), None
  :fun void_if_set!: @_p.assert_union!(0x0, 0), None

  :fun is_bool: @_p.check_union(0x0, 1)
  :fun bool!: @_p.assert_union!(0x0, 1), None
  :fun bool_if_set!: @_p.assert_union!(0x0, 1), None

  :fun is_int8: @_p.check_union(0x0, 2)
  :fun int8!: @_p.assert_union!(0x0, 2), None
  :fun int8_if_set!: @_p.assert_union!(0x0, 2), None

  :fun is_int16: @_p.check_union(0x0, 3)
  :fun int16!: @_p.assert_union!(0x0, 3), None
  :fun int16_if_set!: @_p.assert_union!(0x0, 3), None

  :fun is_int32: @_p.check_union(0x0, 4)
  :fun int32!: @_p.assert_union!(0x0, 4), None
  :fun int32_if_set!: @_p.assert_union!(0x0, 4), None

  :fun is_int64: @_p.check_union(0x0, 5)
  :fun int64!: @_p.assert_union!(0x0, 5), None
  :fun int64_if_set!: @_p.assert_union!(0x0, 5), None

  :fun is_uint8: @_p.check_union(0x0, 6)
  :fun uint8!: @_p.assert_union!(0x0, 6), None
  :fun uint8_if_set!: @_p.assert_union!(0x0, 6), None

  :fun is_uint16: @_p.check_union(0x0, 7)
  :fun uint16!: @_p.assert_union!(0x0, 7), None
  :fun uint16_if_set!: @_p.assert_union!(0x0, 7), None

  :fun is_uint32: @_p.check_union(0x0, 8)
  :fun uint32!: @_p.assert_union!(0x0, 8), None
  :fun uint32_if_set!: @_p.assert_union!(0x0, 8), None

  :fun is_uint64: @_p.check_union(0x0, 9)
  :fun uint64!: @_p.assert_union!(0x0, 9), None
  :fun uint64_if_set!: @_p.assert_union!(0x0, 9), None

  :fun is_float32: @_p.check_union(0x0, 10)
  :fun float32!: @_p.assert_union!(0x0, 10), None
  :fun float32_if_set!: @_p.assert_union!(0x0, 10), None

  :fun is_float64: @_p.check_union(0x0, 11)
  :fun float64!: @_p.assert_union!(0x0, 11), None
  :fun float64_if_set!: @_p.assert_union!(0x0, 11), None

  :fun is_text: @_p.check_union(0x0, 12)
  :fun text!: @_p.assert_union!(0x0, 12), None
  :fun text_if_set!: @_p.assert_union!(0x0, 12), None

  :fun is_data: @_p.check_union(0x0, 13)
  :fun data!: @_p.assert_union!(0x0, 13), None
  :fun data_if_set!: @_p.assert_union!(0x0, 13), None

  :fun is_list: @_p.check_union(0x0, 14)
  :fun list!: @_p.assert_union!(0x0, 14), CapnProto.Meta.Type.AS_list.read_from_pointer(@_p)
  :fun list_if_set!: @_p.assert_union!(0x0, 14), CapnProto.Meta.Type.AS_list.read_from_pointer(@_p)

  :fun is_enum: @_p.check_union(0x0, 15)
  :fun enum!: @_p.assert_union!(0x0, 15), CapnProto.Meta.Type.AS_enum.read_from_pointer(@_p)
  :fun enum_if_set!: @_p.assert_union!(0x0, 15), CapnProto.Meta.Type.AS_enum.read_from_pointer(@_p)

  :fun is_struct: @_p.check_union(0x0, 16)
  :fun struct!: @_p.assert_union!(0x0, 16), CapnProto.Meta.Type.AS_struct.read_from_pointer(@_p)
  :fun struct_if_set!: @_p.assert_union!(0x0, 16), CapnProto.Meta.Type.AS_struct.read_from_pointer(@_p)

  :fun is_interface: @_p.check_union(0x0, 17)
  :fun interface!: @_p.assert_union!(0x0, 17), CapnProto.Meta.Type.AS_interface.read_from_pointer(@_p)
  :fun interface_if_set!: @_p.assert_union!(0x0, 17), CapnProto.Meta.Type.AS_interface.read_from_pointer(@_p)

  :fun is_any_pointer: @_p.check_union(0x0, 18)
  :fun any_pointer!: @_p.assert_union!(0x0, 18), CapnProto.Meta.Type.AS_anyPointer.read_from_pointer(@_p)
  :fun any_pointer_if_set!: @_p.assert_union!(0x0, 18), CapnProto.Meta.Type.AS_anyPointer.read_from_pointer(@_p)

:struct box CapnProto.Meta.Type.AS_list
  :let _p CapnProto.Pointer.Struct
  :new box read_from_pointer(@_p)

  :const capn_proto_data_word_count U16: 3
  :const capn_proto_pointer_count U16: 1

  :is TraceData
  :fun trace_data(trace TraceData.Observer)
    trace.object(0) -> (
      try trace.property("element_type", @element_type_if_set!)
    )

  :fun element_type: CapnProto.Meta.Type.read_from_pointer(@_p.struct(0))
  :fun element_type_if_set!: CapnProto.Meta.Type.read_from_pointer(@_p.struct_if_set!(0))

:struct box CapnProto.Meta.Type.AS_enum
  :let _p CapnProto.Pointer.Struct
  :new box read_from_pointer(@_p)

  :const capn_proto_data_word_count U16: 3
  :const capn_proto_pointer_count U16: 1

  :is TraceData
  :fun trace_data(trace TraceData.Observer)
    trace.object(0) -> (
      try trace.property("type_id", @type_id_if_set!)
      try trace.property("brand", @brand_if_set!)
    )

  :fun type_id: @_p.u64(0x8)
  :fun type_id_if_set!: @_p.u64_if_set!(0x8)

  :fun brand: CapnProto.Meta.Brand.read_from_pointer(@_p.struct(0))
  :fun brand_if_set!: CapnProto.Meta.Brand.read_from_pointer(@_p.struct_if_set!(0))

:struct box CapnProto.Meta.Type.AS_struct
  :let _p CapnProto.Pointer.Struct
  :new box read_from_pointer(@_p)

  :const capn_proto_data_word_count U16: 3
  :const capn_proto_pointer_count U16: 1

  :is TraceData
  :fun trace_data(trace TraceData.Observer)
    trace.object(0) -> (
      try trace.property("type_id", @type_id_if_set!)
      try trace.property("brand", @brand_if_set!)
    )

  :fun type_id: @_p.u64(0x8)
  :fun type_id_if_set!: @_p.u64_if_set!(0x8)

  :fun brand: CapnProto.Meta.Brand.read_from_pointer(@_p.struct(0))
  :fun brand_if_set!: CapnProto.Meta.Brand.read_from_pointer(@_p.struct_if_set!(0))

:struct box CapnProto.Meta.Type.AS_interface
  :let _p CapnProto.Pointer.Struct
  :new box read_from_pointer(@_p)

  :const capn_proto_data_word_count U16: 3
  :const capn_proto_pointer_count U16: 1

  :is TraceData
  :fun trace_data(trace TraceData.Observer)
    trace.object(0) -> (
      try trace.property("type_id", @type_id_if_set!)
      try trace.property("brand", @brand_if_set!)
    )

  :fun type_id: @_p.u64(0x8)
  :fun type_id_if_set!: @_p.u64_if_set!(0x8)

  :fun brand: CapnProto.Meta.Brand.read_from_pointer(@_p.struct(0))
  :fun brand_if_set!: CapnProto.Meta.Brand.read_from_pointer(@_p.struct_if_set!(0))

:struct box CapnProto.Meta.Type.AS_anyPointer
  :let _p CapnProto.Pointer.Struct
  :new box read_from_pointer(@_p)

  :const capn_proto_data_word_count U16: 3
  :const capn_proto_pointer_count U16: 1

  :is TraceData
  :fun trace_data(trace TraceData.Observer)
    trace.object(0) -> (
      try trace.property("unconstrained", @unconstrained!)
      try trace.property("parameter", @parameter!)
      try trace.property("implicit_method_parameter", @implicit_method_parameter!)
    )

  :fun is_unconstrained: @_p.check_union(0x8, 0)
  :fun unconstrained!: @_p.assert_union!(0x8, 0), CapnProto.Meta.Type.AS_anyPointer.AS_unconstrained.read_from_pointer(@_p)
  :fun unconstrained_if_set!: @_p.assert_union!(0x8, 0), CapnProto.Meta.Type.AS_anyPointer.AS_unconstrained.read_from_pointer(@_p)

  :fun is_parameter: @_p.check_union(0x8, 1)
  :fun parameter!: @_p.assert_union!(0x8, 1), CapnProto.Meta.Type.AS_anyPointer.AS_parameter.read_from_pointer(@_p)
  :fun parameter_if_set!: @_p.assert_union!(0x8, 1), CapnProto.Meta.Type.AS_anyPointer.AS_parameter.read_from_pointer(@_p)

  :fun is_implicit_method_parameter: @_p.check_union(0x8, 2)
  :fun implicit_method_parameter!: @_p.assert_union!(0x8, 2), CapnProto.Meta.Type.AS_anyPointer.AS_implicitMethodParameter.read_from_pointer(@_p)
  :fun implicit_method_parameter_if_set!: @_p.assert_union!(0x8, 2), CapnProto.Meta.Type.AS_anyPointer.AS_implicitMethodParameter.read_from_pointer(@_p)

:struct box CapnProto.Meta.Type.AS_anyPointer.AS_unconstrained
  :let _p CapnProto.Pointer.Struct
  :new box read_from_pointer(@_p)

  :const capn_proto_data_word_count U16: 3
  :const capn_proto_pointer_count U16: 1

  :is TraceData
  :fun trace_data(trace TraceData.Observer)
    trace.object(0) -> (
      try trace.property("any_kind", @any_kind!)
      try trace.property("struct", @struct!)
      try trace.property("list", @list!)
      try trace.property("capability", @capability!)
    )

  :fun is_any_kind: @_p.check_union(0xa, 0)
  :fun any_kind!: @_p.assert_union!(0xa, 0), None
  :fun any_kind_if_set!: @_p.assert_union!(0xa, 0), None

  :fun is_struct: @_p.check_union(0xa, 1)
  :fun struct!: @_p.assert_union!(0xa, 1), None
  :fun struct_if_set!: @_p.assert_union!(0xa, 1), None

  :fun is_list: @_p.check_union(0xa, 2)
  :fun list!: @_p.assert_union!(0xa, 2), None
  :fun list_if_set!: @_p.assert_union!(0xa, 2), None

  :fun is_capability: @_p.check_union(0xa, 3)
  :fun capability!: @_p.assert_union!(0xa, 3), None
  :fun capability_if_set!: @_p.assert_union!(0xa, 3), None

:struct box CapnProto.Meta.Type.AS_anyPointer.AS_parameter
  :let _p CapnProto.Pointer.Struct
  :new box read_from_pointer(@_p)

  :const capn_proto_data_word_count U16: 3
  :const capn_proto_pointer_count U16: 1

  :is TraceData
  :fun trace_data(trace TraceData.Observer)
    trace.object(0) -> (
      try trace.property("scope_id", @scope_id_if_set!)
      try trace.property("parameter_index", @parameter_index_if_set!)
    )

  :fun scope_id: @_p.u64(0x10)
  :fun scope_id_if_set!: @_p.u64_if_set!(0x10)

  :fun parameter_index: @_p.u16(0xa)
  :fun parameter_index_if_set!: @_p.u16_if_set!(0xa)

:struct box CapnProto.Meta.Type.AS_anyPointer.AS_implicitMethodParameter
  :let _p CapnProto.Pointer.Struct
  :new box read_from_pointer(@_p)

  :const capn_proto_data_word_count U16: 3
  :const capn_proto_pointer_count U16: 1

  :is TraceData
  :fun trace_data(trace TraceData.Observer)
    trace.object(0) -> (
      try trace.property("parameter_index", @parameter_index_if_set!)
    )

  :fun parameter_index: @_p.u16(0xa)
  :fun parameter_index_if_set!: @_p.u16_if_set!(0xa)

:struct box CapnProto.Meta.Brand
  :let _p CapnProto.Pointer.Struct
  :new box read_from_pointer(@_p)

  :const capn_proto_data_word_count U16: 0
  :const capn_proto_pointer_count U16: 1

  :is TraceData
  :fun trace_data(trace TraceData.Observer)
    trace.object(@_p.absolute_address) -> (
      try trace.property("scopes", @scopes_if_set!)
    )

  :fun scopes: CapnProto.List(CapnProto.Meta.Brand.Scope).read_from_pointer(@_p.list(0))
  :fun scopes_if_set!: CapnProto.List(CapnProto.Meta.Brand.Scope).read_from_pointer(@_p.list_if_set!(0))

:struct box CapnProto.Meta.Brand.Scope
  :let _p CapnProto.Pointer.Struct
  :new box read_from_pointer(@_p)

  :const capn_proto_data_word_count U16: 2
  :const capn_proto_pointer_count U16: 1

  :is TraceData
  :fun trace_data(trace TraceData.Observer)
    trace.object(@_p.absolute_address) -> (
      try trace.property("scope_id", @scope_id_if_set!)
      try trace.property("bind", @bind!)
      try trace.property("inherit", @inherit!)
    )

  :fun scope_id: @_p.u64(0x0)
  :fun scope_id_if_set!: @_p.u64_if_set!(0x0)

  :fun is_bind: @_p.check_union(0x8, 0)
  :fun bind!: @_p.assert_union!(0x8, 0), CapnProto.List(CapnProto.Meta.Brand.Binding).read_from_pointer(@_p.list(0))
  :fun bind_if_set!: @_p.assert_union!(0x8, 0), CapnProto.List(CapnProto.Meta.Brand.Binding).read_from_pointer(@_p.list_if_set!(0))

  :fun is_inherit: @_p.check_union(0x8, 1)
  :fun inherit!: @_p.assert_union!(0x8, 1), None
  :fun inherit_if_set!: @_p.assert_union!(0x8, 1), None

:struct box CapnProto.Meta.Brand.Binding
  :let _p CapnProto.Pointer.Struct
  :new box read_from_pointer(@_p)

  :const capn_proto_data_word_count U16: 1
  :const capn_proto_pointer_count U16: 1

  :is TraceData
  :fun trace_data(trace TraceData.Observer)
    trace.object(@_p.absolute_address) -> (
      try trace.property("unbound", @unbound!)
      try trace.property("type", @type!)
    )

  :fun is_unbound: @_p.check_union(0x0, 0)
  :fun unbound!: @_p.assert_union!(0x0, 0), None
  :fun unbound_if_set!: @_p.assert_union!(0x0, 0), None

  :fun is_type: @_p.check_union(0x0, 1)
  :fun type!: @_p.assert_union!(0x0, 1), CapnProto.Meta.Type.read_from_pointer(@_p.struct(0))
  :fun type_if_set!: @_p.assert_union!(0x0, 1), CapnProto.Meta.Type.read_from_pointer(@_p.struct_if_set!(0))

:struct box CapnProto.Meta.Value
  :let _p CapnProto.Pointer.Struct
  :new box read_from_pointer(@_p)

  :const capn_proto_data_word_count U16: 2
  :const capn_proto_pointer_count U16: 1

  :is TraceData
  :fun trace_data(trace TraceData.Observer)
    trace.object(@_p.absolute_address) -> (
      try trace.property("void", @void!)
      try trace.property("bool", @bool!)
      try trace.property("int8", @int8!)
      try trace.property("int16", @int16!)
      try trace.property("int32", @int32!)
      try trace.property("int64", @int64!)
      try trace.property("uint8", @uint8!)
      try trace.property("uint16", @uint16!)
      try trace.property("uint32", @uint32!)
      try trace.property("uint64", @uint64!)
      try trace.property("float32", @float32!)
      try trace.property("float64", @float64!)
      try trace.property("text", @text!)
      try trace.property("data", @data!)
      try trace.property("list", @list!)
      try trace.property("enum", @enum!)
      try trace.property("struct", @struct!)
      try trace.property("interface", @interface!)
      try trace.property("any_pointer", @any_pointer!)
    )

  :fun is_void: @_p.check_union(0x0, 0)
  :fun void!: @_p.assert_union!(0x0, 0), None
  :fun void_if_set!: @_p.assert_union!(0x0, 0), None

  :fun is_bool: @_p.check_union(0x0, 1)
  :fun bool!: @_p.assert_union!(0x0, 1), @_p.bool(0x2, 0b00000001)
  :fun bool_if_set!: @_p.assert_union!(0x0, 1), @_p.bool_if_set!(0x2, 0b00000001)

  :fun is_int8: @_p.check_union(0x0, 2)
  :fun int8!: @_p.assert_union!(0x0, 2), @_p.i8(0x2)
  :fun int8_if_set!: @_p.assert_union!(0x0, 2), @_p.i8_if_set!(0x2)

  :fun is_int16: @_p.check_union(0x0, 3)
  :fun int16!: @_p.assert_union!(0x0, 3), @_p.i16(0x2)
  :fun int16_if_set!: @_p.assert_union!(0x0, 3), @_p.i16_if_set!(0x2)

  :fun is_int32: @_p.check_union(0x0, 4)
  :fun int32!: @_p.assert_union!(0x0, 4), @_p.i32(0x4)
  :fun int32_if_set!: @_p.assert_union!(0x0, 4), @_p.i32_if_set!(0x4)

  :fun is_int64: @_p.check_union(0x0, 5)
  :fun int64!: @_p.assert_union!(0x0, 5), @_p.i64(0x8)
  :fun int64_if_set!: @_p.assert_union!(0x0, 5), @_p.i64_if_set!(0x8)

  :fun is_uint8: @_p.check_union(0x0, 6)
  :fun uint8!: @_p.assert_union!(0x0, 6), @_p.u8(0x2)
  :fun uint8_if_set!: @_p.assert_union!(0x0, 6), @_p.u8_if_set!(0x2)

  :fun is_uint16: @_p.check_union(0x0, 7)
  :fun uint16!: @_p.assert_union!(0x0, 7), @_p.u16(0x2)
  :fun uint16_if_set!: @_p.assert_union!(0x0, 7), @_p.u16_if_set!(0x2)

  :fun is_uint32: @_p.check_union(0x0, 8)
  :fun uint32!: @_p.assert_union!(0x0, 8), @_p.u32(0x4)
  :fun uint32_if_set!: @_p.assert_union!(0x0, 8), @_p.u32_if_set!(0x4)

  :fun is_uint64: @_p.check_union(0x0, 9)
  :fun uint64!: @_p.assert_union!(0x0, 9), @_p.u64(0x8)
  :fun uint64_if_set!: @_p.assert_union!(0x0, 9), @_p.u64_if_set!(0x8)

  :fun is_float32: @_p.check_union(0x0, 10)
  :fun float32!: @_p.assert_union!(0x0, 10), @_p.f32(0x4)
  :fun float32_if_set!: @_p.assert_union!(0x0, 10), @_p.f32_if_set!(0x4)

  :fun is_float64: @_p.check_union(0x0, 11)
  :fun float64!: @_p.assert_union!(0x0, 11), @_p.f64(0x8)
  :fun float64_if_set!: @_p.assert_union!(0x0, 11), @_p.f64_if_set!(0x8)

  :fun is_text: @_p.check_union(0x0, 12)
  :fun text!: @_p.assert_union!(0x0, 12), @_p.text(0)
  :fun text_if_set!: @_p.assert_union!(0x0, 12), @_p.text_if_set!(0)

  :fun is_data: @_p.check_union(0x0, 13)
  :fun data!: @_p.assert_union!(0x0, 13), @_p.data(0)
  :fun data_if_set!: @_p.assert_union!(0x0, 13), @_p.data_if_set!(0)

  :fun is_list: @_p.check_union(0x0, 14)
  :fun list!: @_p.assert_union!(0x0, 14), None // UNHANDLED: anyPointer
  :fun list_if_set!: @_p.assert_union!(0x0, 14), None // UNHANDLED: anyPointer

  :fun is_enum: @_p.check_union(0x0, 15)
  :fun enum!: @_p.assert_union!(0x0, 15), @_p.u16(0x2)
  :fun enum_if_set!: @_p.assert_union!(0x0, 15), @_p.u16_if_set!(0x2)

  :fun is_struct: @_p.check_union(0x0, 16)
  :fun struct!: @_p.assert_union!(0x0, 16), None // UNHANDLED: anyPointer
  :fun struct_if_set!: @_p.assert_union!(0x0, 16), None // UNHANDLED: anyPointer

  :fun is_interface: @_p.check_union(0x0, 17)
  :fun interface!: @_p.assert_union!(0x0, 17), None
  :fun interface_if_set!: @_p.assert_union!(0x0, 17), None

  :fun is_any_pointer: @_p.check_union(0x0, 18)
  :fun any_pointer!: @_p.assert_union!(0x0, 18), None // UNHANDLED: anyPointer
  :fun any_pointer_if_set!: @_p.assert_union!(0x0, 18), None // UNHANDLED: anyPointer

:struct box CapnProto.Meta.Annotation
  :let _p CapnProto.Pointer.Struct
  :new box read_from_pointer(@_p)

  :const capn_proto_data_word_count U16: 1
  :const capn_proto_pointer_count U16: 2

  :is TraceData
  :fun trace_data(trace TraceData.Observer)
    trace.object(@_p.absolute_address) -> (
      try trace.property("id", @id_if_set!)
      try trace.property("value", @value_if_set!)
      try trace.property("brand", @brand_if_set!)
    )

  :fun id: @_p.u64(0x0)
  :fun id_if_set!: @_p.u64_if_set!(0x0)

  :fun value: CapnProto.Meta.Value.read_from_pointer(@_p.struct(0))
  :fun value_if_set!: CapnProto.Meta.Value.read_from_pointer(@_p.struct_if_set!(0))

  :fun brand: CapnProto.Meta.Brand.read_from_pointer(@_p.struct(1))
  :fun brand_if_set!: CapnProto.Meta.Brand.read_from_pointer(@_p.struct_if_set!(1))

:enum CapnProto.Meta.ElementSize
  :bit_width 16

  :member Empty 0
  :member Bit 1
  :member Byte 2
  :member TwoBytes 3
  :member FourBytes 4
  :member EightBytes 5
  :member Pointer 6
  :member InlineComposite 7

  :fun non _new(u16 U16)
    try (
      @from_u64!(u16.u64)
    |
      CapnProto.Meta.ElementSize.Empty
    )

:struct box CapnProto.Meta.CodeGeneratorRequest
  :let _p CapnProto.Pointer.Struct
  :new box read_from_pointer(@_p)

  :const capn_proto_data_word_count U16: 0
  :const capn_proto_pointer_count U16: 2

  :is TraceData
  :fun trace_data(trace TraceData.Observer)
    trace.object(@_p.absolute_address) -> (
      try trace.property("nodes", @nodes_if_set!)
      try trace.property("requested_files", @requested_files_if_set!)
    )

  :fun nodes: CapnProto.List(CapnProto.Meta.Node).read_from_pointer(@_p.list(0))
  :fun nodes_if_set!: CapnProto.List(CapnProto.Meta.Node).read_from_pointer(@_p.list_if_set!(0))

  :fun requested_files: CapnProto.List(CapnProto.Meta.CodeGeneratorRequest.RequestedFile).read_from_pointer(@_p.list(1))
  :fun requested_files_if_set!: CapnProto.List(CapnProto.Meta.CodeGeneratorRequest.RequestedFile).read_from_pointer(@_p.list_if_set!(1))

:struct box CapnProto.Meta.CodeGeneratorRequest.RequestedFile
  :let _p CapnProto.Pointer.Struct
  :new box read_from_pointer(@_p)

  :const capn_proto_data_word_count U16: 1
  :const capn_proto_pointer_count U16: 2

  :is TraceData
  :fun trace_data(trace TraceData.Observer)
    trace.object(@_p.absolute_address) -> (
      try trace.property("id", @id_if_set!)
      try trace.property("filename", @filename_if_set!)
      try trace.property("imports", @imports_if_set!)
    )

  :fun id: @_p.u64(0x0)
  :fun id_if_set!: @_p.u64_if_set!(0x0)

  :fun filename: @_p.text(0)
  :fun filename_if_set!: @_p.text_if_set!(0)

  :fun imports: CapnProto.List(CapnProto.Meta.CodeGeneratorRequest.RequestedFile.Import).read_from_pointer(@_p.list(1))
  :fun imports_if_set!: CapnProto.List(CapnProto.Meta.CodeGeneratorRequest.RequestedFile.Import).read_from_pointer(@_p.list_if_set!(1))

:struct box CapnProto.Meta.CodeGeneratorRequest.RequestedFile.Import
  :let _p CapnProto.Pointer.Struct
  :new box read_from_pointer(@_p)

  :const capn_proto_data_word_count U16: 1
  :const capn_proto_pointer_count U16: 1

  :is TraceData
  :fun trace_data(trace TraceData.Observer)
    trace.object(@_p.absolute_address) -> (
      try trace.property("id", @id_if_set!)
      try trace.property("name", @name_if_set!)
    )

  :fun id: @_p.u64(0x0)
  :fun id_if_set!: @_p.u64_if_set!(0x0)

  :fun name: @_p.text(0)
  :fun name_if_set!: @_p.text_if_set!(0)

:struct CapnProto.Meta.Node.Builder
  :let _p CapnProto.Pointer.Struct.Builder
  :new from_pointer(@_p)
  :fun as_reader: CapnProto.Meta.Node.read_from_pointer(@_p.as_reader)

  :const capn_proto_data_word_count U16: 5
  :const capn_proto_pointer_count U16: 6

  :is TraceData
  :fun trace_data(trace TraceData.Observer)
    @as_reader.trace_data(trace)

  :fun id: @_p.u64(0x0)
  :fun id_if_set!: @_p.u64_if_set!(0x0)
  :fun ref "id="(new_value): @_p.set_u64(0x0, new_value, 0)

  :fun ref display_name: @_p.text(0)
  :fun ref display_name_if_set!: @_p.text_if_set!(0)
  :fun ref "display_name="(new_value): @_p.set_text(0, new_value, "")

  :fun display_name_prefix_length: @_p.u32(0x8)
  :fun display_name_prefix_length_if_set!: @_p.u32_if_set!(0x8)
  :fun ref "display_name_prefix_length="(new_value): @_p.set_u32(0x8, new_value, 0)

  :fun scope_id: @_p.u64(0x10)
  :fun scope_id_if_set!: @_p.u64_if_set!(0x10)
  :fun ref "scope_id="(new_value): @_p.set_u64(0x10, new_value, 0)

  :fun ref nested_nodes: CapnProto.List.Builder(CapnProto.Meta.Node.NestedNode.Builder).from_pointer(@_p.list(1))
  :fun ref nested_nodes_if_set!: CapnProto.List.Builder(CapnProto.Meta.Node.NestedNode.Builder).from_pointer(@_p.list_if_set!(1))
  :fun ref init_nested_nodes(new_count)
    CapnProto.List.Builder(CapnProto.Meta.Node.NestedNode.Builder).from_pointer(@_p.init_list(1, 1, 1, new_count))
  :fun ref trim_nested_nodes(new_start, new_finish)
    CapnProto.List.Builder(CapnProto.Meta.Node.NestedNode.Builder).from_pointer(@_p.trim_list(1, 1, 1, new_start, new_finish))

  :fun ref annotations: CapnProto.List.Builder(CapnProto.Meta.Annotation.Builder).from_pointer(@_p.list(2))
  :fun ref annotations_if_set!: CapnProto.List.Builder(CapnProto.Meta.Annotation.Builder).from_pointer(@_p.list_if_set!(2))
  :fun ref init_annotations(new_count)
    CapnProto.List.Builder(CapnProto.Meta.Annotation.Builder).from_pointer(@_p.init_list(2, 1, 2, new_count))
  :fun ref trim_annotations(new_start, new_finish)
    CapnProto.List.Builder(CapnProto.Meta.Annotation.Builder).from_pointer(@_p.trim_list(2, 1, 2, new_start, new_finish))

  :fun is_file: @_p.check_union(0xc, 0)
  :fun file!: @_p.assert_union!(0xc, 0), None
  :fun file_if_set!: @_p.assert_union!(0xc, 0), None
  :fun ref init_file
    @_p.mark_union(0xc, 0)
    None

  :fun is_struct: @_p.check_union(0xc, 1)
  :fun ref struct!: @_p.assert_union!(0xc, 1), CapnProto.Meta.Node.AS_struct.Builder.from_pointer(@_p)
  :fun ref struct_if_set!: @_p.assert_union!(0xc, 1), CapnProto.Meta.Node.AS_struct.Builder.from_pointer(@_p)
  :fun ref init_struct
    @_p.clear_16(0xe) // data_word_count
    @_p.clear_16(0x18) // pointer_count
    @_p.clear_16(0x1a) // preferred_list_encoding
    @_p.set_bool(0x1c, 0b00000001, False) // is_group
    @_p.clear_16(0x1e) // discriminant_count
    @_p.clear_32(0x20) // discriminant_offset
    @_p.clear_pointer(3) // fields
    @_p.mark_union(0xc, 1)
    CapnProto.Meta.Node.AS_struct.Builder.from_pointer(@_p)

  :fun is_enum: @_p.check_union(0xc, 2)
  :fun ref enum!: @_p.assert_union!(0xc, 2), CapnProto.Meta.Node.AS_enum.Builder.from_pointer(@_p)
  :fun ref enum_if_set!: @_p.assert_union!(0xc, 2), CapnProto.Meta.Node.AS_enum.Builder.from_pointer(@_p)
  :fun ref init_enum
    @_p.clear_pointer(3) // enumerants
    @_p.mark_union(0xc, 2)
    CapnProto.Meta.Node.AS_enum.Builder.from_pointer(@_p)

  :fun is_interface: @_p.check_union(0xc, 3)
  :fun ref interface!: @_p.assert_union!(0xc, 3), CapnProto.Meta.Node.AS_interface.Builder.from_pointer(@_p)
  :fun ref interface_if_set!: @_p.assert_union!(0xc, 3), CapnProto.Meta.Node.AS_interface.Builder.from_pointer(@_p)
  :fun ref init_interface
    @_p.clear_pointer(3) // methods
    @_p.clear_pointer(4) // superclasses
    @_p.mark_union(0xc, 3)
    CapnProto.Meta.Node.AS_interface.Builder.from_pointer(@_p)

  :fun is_const: @_p.check_union(0xc, 4)
  :fun ref const!: @_p.assert_union!(0xc, 4), CapnProto.Meta.Node.AS_const.Builder.from_pointer(@_p)
  :fun ref const_if_set!: @_p.assert_union!(0xc, 4), CapnProto.Meta.Node.AS_const.Builder.from_pointer(@_p)
  :fun ref init_const
    @_p.clear_pointer(3) // type
    @_p.clear_pointer(4) // value
    @_p.mark_union(0xc, 4)
    CapnProto.Meta.Node.AS_const.Builder.from_pointer(@_p)

  :fun is_annotation: @_p.check_union(0xc, 5)
  :fun ref annotation!: @_p.assert_union!(0xc, 5), CapnProto.Meta.Node.AS_annotation.Builder.from_pointer(@_p)
  :fun ref annotation_if_set!: @_p.assert_union!(0xc, 5), CapnProto.Meta.Node.AS_annotation.Builder.from_pointer(@_p)
  :fun ref init_annotation
    @_p.clear_pointer(3) // type
    @_p.set_bool(0xe, 0b00000001, False) // targets_file
    @_p.set_bool(0xe, 0b00000010, False) // targets_const
    @_p.set_bool(0xe, 0b00000100, False) // targets_enum
    @_p.set_bool(0xe, 0b00001000, False) // targets_enumerant
    @_p.set_bool(0xe, 0b00010000, False) // targets_struct
    @_p.set_bool(0xe, 0b00100000, False) // targets_field
    @_p.set_bool(0xe, 0b01000000, False) // targets_union
    @_p.set_bool(0xe, 0b10000000, False) // targets_group
    @_p.set_bool(0xf, 0b00000001, False) // targets_interface
    @_p.set_bool(0xf, 0b00000010, False) // targets_method
    @_p.set_bool(0xf, 0b00000100, False) // targets_param
    @_p.set_bool(0xf, 0b00001000, False) // targets_annotation
    @_p.mark_union(0xc, 5)
    CapnProto.Meta.Node.AS_annotation.Builder.from_pointer(@_p)

  :fun ref parameters: CapnProto.List.Builder(CapnProto.Meta.Node.Parameter.Builder).from_pointer(@_p.list(5))
  :fun ref parameters_if_set!: CapnProto.List.Builder(CapnProto.Meta.Node.Parameter.Builder).from_pointer(@_p.list_if_set!(5))
  :fun ref init_parameters(new_count)
    CapnProto.List.Builder(CapnProto.Meta.Node.Parameter.Builder).from_pointer(@_p.init_list(5, 0, 1, new_count))
  :fun ref trim_parameters(new_start, new_finish)
    CapnProto.List.Builder(CapnProto.Meta.Node.Parameter.Builder).from_pointer(@_p.trim_list(5, 0, 1, new_start, new_finish))

  :fun is_generic: @_p.bool(0x24, 0b00000001)
  :fun is_generic_if_set!: @_p.bool_if_set!(0x24, 0b00000001)
  :fun ref "is_generic="(new_value): @_p.set_bool(0x24, 0b00000001, Bool[new_value])

:struct CapnProto.Meta.Node.AS_struct.Builder
  :let _p CapnProto.Pointer.Struct.Builder
  :new from_pointer(@_p)
  :fun as_reader: CapnProto.Meta.Node.AS_struct.read_from_pointer(@_p.as_reader)

  :const capn_proto_data_word_count U16: 5
  :const capn_proto_pointer_count U16: 6

  :is TraceData
  :fun trace_data(trace TraceData.Observer)
    @as_reader.trace_data(trace)

  :fun data_word_count: @_p.u16(0xe)
  :fun data_word_count_if_set!: @_p.u16_if_set!(0xe)
  :fun ref "data_word_count="(new_value): @_p.set_u16(0xe, new_value, 0)

  :fun pointer_count: @_p.u16(0x18)
  :fun pointer_count_if_set!: @_p.u16_if_set!(0x18)
  :fun ref "pointer_count="(new_value): @_p.set_u16(0x18, new_value, 0)

  :fun preferred_list_encoding: CapnProto.Meta.ElementSize._new(@_p.u16(0x1a))
  :fun preferred_list_encoding_if_set!: CapnProto.Meta.ElementSize._new(@_p.u16_if_set!(0x1a))
  :fun ref "preferred_list_encoding="(new_value): @_p.set_u16(0x1a, CapnProto.Meta.ElementSize[new_value].u16, 0)

  :fun is_group: @_p.bool(0x1c, 0b00000001)
  :fun is_group_if_set!: @_p.bool_if_set!(0x1c, 0b00000001)
  :fun ref "is_group="(new_value): @_p.set_bool(0x1c, 0b00000001, Bool[new_value])

  :fun discriminant_count: @_p.u16(0x1e)
  :fun discriminant_count_if_set!: @_p.u16_if_set!(0x1e)
  :fun ref "discriminant_count="(new_value): @_p.set_u16(0x1e, new_value, 0)

  :fun discriminant_offset: @_p.u32(0x20)
  :fun discriminant_offset_if_set!: @_p.u32_if_set!(0x20)
  :fun ref "discriminant_offset="(new_value): @_p.set_u32(0x20, new_value, 0)

  :fun ref fields: CapnProto.List.Builder(CapnProto.Meta.Field.Builder).from_pointer(@_p.list(3))
  :fun ref fields_if_set!: CapnProto.List.Builder(CapnProto.Meta.Field.Builder).from_pointer(@_p.list_if_set!(3))
  :fun ref init_fields(new_count)
    CapnProto.List.Builder(CapnProto.Meta.Field.Builder).from_pointer(@_p.init_list(3, 3, 4, new_count))
  :fun ref trim_fields(new_start, new_finish)
    CapnProto.List.Builder(CapnProto.Meta.Field.Builder).from_pointer(@_p.trim_list(3, 3, 4, new_start, new_finish))

:struct CapnProto.Meta.Node.AS_enum.Builder
  :let _p CapnProto.Pointer.Struct.Builder
  :new from_pointer(@_p)
  :fun as_reader: CapnProto.Meta.Node.AS_enum.read_from_pointer(@_p.as_reader)

  :const capn_proto_data_word_count U16: 5
  :const capn_proto_pointer_count U16: 6

  :is TraceData
  :fun trace_data(trace TraceData.Observer)
    @as_reader.trace_data(trace)

  :fun ref enumerants: CapnProto.List.Builder(CapnProto.Meta.Enumerant.Builder).from_pointer(@_p.list(3))
  :fun ref enumerants_if_set!: CapnProto.List.Builder(CapnProto.Meta.Enumerant.Builder).from_pointer(@_p.list_if_set!(3))
  :fun ref init_enumerants(new_count)
    CapnProto.List.Builder(CapnProto.Meta.Enumerant.Builder).from_pointer(@_p.init_list(3, 1, 2, new_count))
  :fun ref trim_enumerants(new_start, new_finish)
    CapnProto.List.Builder(CapnProto.Meta.Enumerant.Builder).from_pointer(@_p.trim_list(3, 1, 2, new_start, new_finish))

:struct CapnProto.Meta.Node.AS_interface.Builder
  :let _p CapnProto.Pointer.Struct.Builder
  :new from_pointer(@_p)
  :fun as_reader: CapnProto.Meta.Node.AS_interface.read_from_pointer(@_p.as_reader)

  :const capn_proto_data_word_count U16: 5
  :const capn_proto_pointer_count U16: 6

  :is TraceData
  :fun trace_data(trace TraceData.Observer)
    @as_reader.trace_data(trace)

  :fun ref methods: CapnProto.List.Builder(CapnProto.Meta.Method.Builder).from_pointer(@_p.list(3))
  :fun ref methods_if_set!: CapnProto.List.Builder(CapnProto.Meta.Method.Builder).from_pointer(@_p.list_if_set!(3))
  :fun ref init_methods(new_count)
    CapnProto.List.Builder(CapnProto.Meta.Method.Builder).from_pointer(@_p.init_list(3, 3, 5, new_count))
  :fun ref trim_methods(new_start, new_finish)
    CapnProto.List.Builder(CapnProto.Meta.Method.Builder).from_pointer(@_p.trim_list(3, 3, 5, new_start, new_finish))

  :fun ref superclasses: CapnProto.List.Builder(CapnProto.Meta.Superclass.Builder).from_pointer(@_p.list(4))
  :fun ref superclasses_if_set!: CapnProto.List.Builder(CapnProto.Meta.Superclass.Builder).from_pointer(@_p.list_if_set!(4))
  :fun ref init_superclasses(new_count)
    CapnProto.List.Builder(CapnProto.Meta.Superclass.Builder).from_pointer(@_p.init_list(4, 1, 1, new_count))
  :fun ref trim_superclasses(new_start, new_finish)
    CapnProto.List.Builder(CapnProto.Meta.Superclass.Builder).from_pointer(@_p.trim_list(4, 1, 1, new_start, new_finish))

:struct CapnProto.Meta.Node.AS_const.Builder
  :let _p CapnProto.Pointer.Struct.Builder
  :new from_pointer(@_p)
  :fun as_reader: CapnProto.Meta.Node.AS_const.read_from_pointer(@_p.as_reader)

  :const capn_proto_data_word_count U16: 5
  :const capn_proto_pointer_count U16: 6

  :is TraceData
  :fun trace_data(trace TraceData.Observer)
    @as_reader.trace_data(trace)

  :fun ref type: CapnProto.Meta.Type.Builder.from_pointer(@_p.struct(3, 3, 1))
  :fun ref type_if_set!: CapnProto.Meta.Type.Builder.from_pointer(@_p.struct_if_set!(3, 3, 1))

  :fun ref value: CapnProto.Meta.Value.Builder.from_pointer(@_p.struct(4, 2, 1))
  :fun ref value_if_set!: CapnProto.Meta.Value.Builder.from_pointer(@_p.struct_if_set!(4, 2, 1))

:struct CapnProto.Meta.Node.AS_annotation.Builder
  :let _p CapnProto.Pointer.Struct.Builder
  :new from_pointer(@_p)
  :fun as_reader: CapnProto.Meta.Node.AS_annotation.read_from_pointer(@_p.as_reader)

  :const capn_proto_data_word_count U16: 5
  :const capn_proto_pointer_count U16: 6

  :is TraceData
  :fun trace_data(trace TraceData.Observer)
    @as_reader.trace_data(trace)

  :fun ref type: CapnProto.Meta.Type.Builder.from_pointer(@_p.struct(3, 3, 1))
  :fun ref type_if_set!: CapnProto.Meta.Type.Builder.from_pointer(@_p.struct_if_set!(3, 3, 1))

  :fun targets_file: @_p.bool(0xe, 0b00000001)
  :fun targets_file_if_set!: @_p.bool_if_set!(0xe, 0b00000001)
  :fun ref "targets_file="(new_value): @_p.set_bool(0xe, 0b00000001, Bool[new_value])

  :fun targets_const: @_p.bool(0xe, 0b00000010)
  :fun targets_const_if_set!: @_p.bool_if_set!(0xe, 0b00000010)
  :fun ref "targets_const="(new_value): @_p.set_bool(0xe, 0b00000010, Bool[new_value])

  :fun targets_enum: @_p.bool(0xe, 0b00000100)
  :fun targets_enum_if_set!: @_p.bool_if_set!(0xe, 0b00000100)
  :fun ref "targets_enum="(new_value): @_p.set_bool(0xe, 0b00000100, Bool[new_value])

  :fun targets_enumerant: @_p.bool(0xe, 0b00001000)
  :fun targets_enumerant_if_set!: @_p.bool_if_set!(0xe, 0b00001000)
  :fun ref "targets_enumerant="(new_value): @_p.set_bool(0xe, 0b00001000, Bool[new_value])

  :fun targets_struct: @_p.bool(0xe, 0b00010000)
  :fun targets_struct_if_set!: @_p.bool_if_set!(0xe, 0b00010000)
  :fun ref "targets_struct="(new_value): @_p.set_bool(0xe, 0b00010000, Bool[new_value])

  :fun targets_field: @_p.bool(0xe, 0b00100000)
  :fun targets_field_if_set!: @_p.bool_if_set!(0xe, 0b00100000)
  :fun ref "targets_field="(new_value): @_p.set_bool(0xe, 0b00100000, Bool[new_value])

  :fun targets_union: @_p.bool(0xe, 0b01000000)
  :fun targets_union_if_set!: @_p.bool_if_set!(0xe, 0b01000000)
  :fun ref "targets_union="(new_value): @_p.set_bool(0xe, 0b01000000, Bool[new_value])

  :fun targets_group: @_p.bool(0xe, 0b10000000)
  :fun targets_group_if_set!: @_p.bool_if_set!(0xe, 0b10000000)
  :fun ref "targets_group="(new_value): @_p.set_bool(0xe, 0b10000000, Bool[new_value])

  :fun targets_interface: @_p.bool(0xf, 0b00000001)
  :fun targets_interface_if_set!: @_p.bool_if_set!(0xf, 0b00000001)
  :fun ref "targets_interface="(new_value): @_p.set_bool(0xf, 0b00000001, Bool[new_value])

  :fun targets_method: @_p.bool(0xf, 0b00000010)
  :fun targets_method_if_set!: @_p.bool_if_set!(0xf, 0b00000010)
  :fun ref "targets_method="(new_value): @_p.set_bool(0xf, 0b00000010, Bool[new_value])

  :fun targets_param: @_p.bool(0xf, 0b00000100)
  :fun targets_param_if_set!: @_p.bool_if_set!(0xf, 0b00000100)
  :fun ref "targets_param="(new_value): @_p.set_bool(0xf, 0b00000100, Bool[new_value])

  :fun targets_annotation: @_p.bool(0xf, 0b00001000)
  :fun targets_annotation_if_set!: @_p.bool_if_set!(0xf, 0b00001000)
  :fun ref "targets_annotation="(new_value): @_p.set_bool(0xf, 0b00001000, Bool[new_value])

:struct CapnProto.Meta.Node.Parameter.Builder
  :let _p CapnProto.Pointer.Struct.Builder
  :new from_pointer(@_p)
  :fun as_reader: CapnProto.Meta.Node.Parameter.read_from_pointer(@_p.as_reader)

  :const capn_proto_data_word_count U16: 0
  :const capn_proto_pointer_count U16: 1

  :is TraceData
  :fun trace_data(trace TraceData.Observer)
    @as_reader.trace_data(trace)

  :fun ref name: @_p.text(0)
  :fun ref name_if_set!: @_p.text_if_set!(0)
  :fun ref "name="(new_value): @_p.set_text(0, new_value, "")

:struct CapnProto.Meta.Node.NestedNode.Builder
  :let _p CapnProto.Pointer.Struct.Builder
  :new from_pointer(@_p)
  :fun as_reader: CapnProto.Meta.Node.NestedNode.read_from_pointer(@_p.as_reader)

  :const capn_proto_data_word_count U16: 1
  :const capn_proto_pointer_count U16: 1

  :is TraceData
  :fun trace_data(trace TraceData.Observer)
    @as_reader.trace_data(trace)

  :fun ref name: @_p.text(0)
  :fun ref name_if_set!: @_p.text_if_set!(0)
  :fun ref "name="(new_value): @_p.set_text(0, new_value, "")

  :fun id: @_p.u64(0x0)
  :fun id_if_set!: @_p.u64_if_set!(0x0)
  :fun ref "id="(new_value): @_p.set_u64(0x0, new_value, 0)

:struct CapnProto.Meta.Field.Builder
  :let _p CapnProto.Pointer.Struct.Builder
  :new from_pointer(@_p)
  :fun as_reader: CapnProto.Meta.Field.read_from_pointer(@_p.as_reader)

  :const capn_proto_data_word_count U16: 3
  :const capn_proto_pointer_count U16: 4

  :const no_discriminant U16: 65535

  :is TraceData
  :fun trace_data(trace TraceData.Observer)
    @as_reader.trace_data(trace)

  :fun ref name: @_p.text(0)
  :fun ref name_if_set!: @_p.text_if_set!(0)
  :fun ref "name="(new_value): @_p.set_text(0, new_value, "")

  :fun code_order: @_p.u16(0x0)
  :fun code_order_if_set!: @_p.u16_if_set!(0x0)
  :fun ref "code_order="(new_value): @_p.set_u16(0x0, new_value, 0)

  :fun ref annotations: CapnProto.List.Builder(CapnProto.Meta.Annotation.Builder).from_pointer(@_p.list(1))
  :fun ref annotations_if_set!: CapnProto.List.Builder(CapnProto.Meta.Annotation.Builder).from_pointer(@_p.list_if_set!(1))
  :fun ref init_annotations(new_count)
    CapnProto.List.Builder(CapnProto.Meta.Annotation.Builder).from_pointer(@_p.init_list(1, 1, 2, new_count))
  :fun ref trim_annotations(new_start, new_finish)
    CapnProto.List.Builder(CapnProto.Meta.Annotation.Builder).from_pointer(@_p.trim_list(1, 1, 2, new_start, new_finish))

  :fun discriminant_value: @_p.u16(0x2).bit_xor(65535)
  :fun discriminant_value_if_set!: @_p.u16_if_set!(0x2).bit_xor(65535)
  :fun ref "discriminant_value="(new_value): @_p.set_u16(0x2, new_value, 65535)

  :fun is_slot: @_p.check_union(0x8, 0)
  :fun ref slot!: @_p.assert_union!(0x8, 0), CapnProto.Meta.Field.AS_slot.Builder.from_pointer(@_p)
  :fun ref slot_if_set!: @_p.assert_union!(0x8, 0), CapnProto.Meta.Field.AS_slot.Builder.from_pointer(@_p)
  :fun ref init_slot
    @_p.clear_32(0x4) // offset
    @_p.clear_pointer(2) // type
    @_p.clear_pointer(3) // default_value
    @_p.set_bool(0x10, 0b00000001, False) // had_explicit_default
    @_p.mark_union(0x8, 0)
    CapnProto.Meta.Field.AS_slot.Builder.from_pointer(@_p)

  :fun is_group: @_p.check_union(0x8, 1)
  :fun ref group!: @_p.assert_union!(0x8, 1), CapnProto.Meta.Field.AS_group.Builder.from_pointer(@_p)
  :fun ref group_if_set!: @_p.assert_union!(0x8, 1), CapnProto.Meta.Field.AS_group.Builder.from_pointer(@_p)
  :fun ref init_group
    @_p.clear_64(0x10) // type_id
    @_p.mark_union(0x8, 1)
    CapnProto.Meta.Field.AS_group.Builder.from_pointer(@_p)

  :fun ref ordinal: CapnProto.Meta.Field.AS_ordinal.Builder.from_pointer(@_p)
  :fun ref ordinal_if_set!: CapnProto.Meta.Field.AS_ordinal.Builder.from_pointer(@_p)

:struct CapnProto.Meta.Field.AS_slot.Builder
  :let _p CapnProto.Pointer.Struct.Builder
  :new from_pointer(@_p)
  :fun as_reader: CapnProto.Meta.Field.AS_slot.read_from_pointer(@_p.as_reader)

  :const capn_proto_data_word_count U16: 3
  :const capn_proto_pointer_count U16: 4

  :is TraceData
  :fun trace_data(trace TraceData.Observer)
    @as_reader.trace_data(trace)

  :fun offset: @_p.u32(0x4)
  :fun offset_if_set!: @_p.u32_if_set!(0x4)
  :fun ref "offset="(new_value): @_p.set_u32(0x4, new_value, 0)

  :fun ref type: CapnProto.Meta.Type.Builder.from_pointer(@_p.struct(2, 3, 1))
  :fun ref type_if_set!: CapnProto.Meta.Type.Builder.from_pointer(@_p.struct_if_set!(2, 3, 1))

  :fun ref default_value: CapnProto.Meta.Value.Builder.from_pointer(@_p.struct(3, 2, 1))
  :fun ref default_value_if_set!: CapnProto.Meta.Value.Builder.from_pointer(@_p.struct_if_set!(3, 2, 1))

  :fun had_explicit_default: @_p.bool(0x10, 0b00000001)
  :fun had_explicit_default_if_set!: @_p.bool_if_set!(0x10, 0b00000001)
  :fun ref "had_explicit_default="(new_value): @_p.set_bool(0x10, 0b00000001, Bool[new_value])

:struct CapnProto.Meta.Field.AS_group.Builder
  :let _p CapnProto.Pointer.Struct.Builder
  :new from_pointer(@_p)
  :fun as_reader: CapnProto.Meta.Field.AS_group.read_from_pointer(@_p.as_reader)

  :const capn_proto_data_word_count U16: 3
  :const capn_proto_pointer_count U16: 4

  :is TraceData
  :fun trace_data(trace TraceData.Observer)
    @as_reader.trace_data(trace)

  :fun type_id: @_p.u64(0x10)
  :fun type_id_if_set!: @_p.u64_if_set!(0x10)
  :fun ref "type_id="(new_value): @_p.set_u64(0x10, new_value, 0)

:struct CapnProto.Meta.Field.AS_ordinal.Builder
  :let _p CapnProto.Pointer.Struct.Builder
  :new from_pointer(@_p)
  :fun as_reader: CapnProto.Meta.Field.AS_ordinal.read_from_pointer(@_p.as_reader)

  :const capn_proto_data_word_count U16: 3
  :const capn_proto_pointer_count U16: 4

  :is TraceData
  :fun trace_data(trace TraceData.Observer)
    @as_reader.trace_data(trace)

  :fun is_implicit: @_p.check_union(0xa, 0)
  :fun implicit!: @_p.assert_union!(0xa, 0), None
  :fun implicit_if_set!: @_p.assert_union!(0xa, 0), None
  :fun ref init_implicit
    @_p.mark_union(0xa, 0)
    None

  :fun is_explicit: @_p.check_union(0xa, 1)
  :fun explicit!: @_p.assert_union!(0xa, 1), @_p.u16(0xc)
  :fun explicit_if_set!: @_p.assert_union!(0xa, 1), @_p.u16_if_set!(0xc)
  :fun ref init_explicit(new_value)
    @_p.set_u16(0xc, new_value, 0)
    @_p.mark_union(0xa, 1)
    @_p.u16(0xc)

:struct CapnProto.Meta.Enumerant.Builder
  :let _p CapnProto.Pointer.Struct.Builder
  :new from_pointer(@_p)
  :fun as_reader: CapnProto.Meta.Enumerant.read_from_pointer(@_p.as_reader)

  :const capn_proto_data_word_count U16: 1
  :const capn_proto_pointer_count U16: 2

  :is TraceData
  :fun trace_data(trace TraceData.Observer)
    @as_reader.trace_data(trace)

  :fun ref name: @_p.text(0)
  :fun ref name_if_set!: @_p.text_if_set!(0)
  :fun ref "name="(new_value): @_p.set_text(0, new_value, "")

  :fun code_order: @_p.u16(0x0)
  :fun code_order_if_set!: @_p.u16_if_set!(0x0)
  :fun ref "code_order="(new_value): @_p.set_u16(0x0, new_value, 0)

  :fun ref annotations: CapnProto.List.Builder(CapnProto.Meta.Annotation.Builder).from_pointer(@_p.list(1))
  :fun ref annotations_if_set!: CapnProto.List.Builder(CapnProto.Meta.Annotation.Builder).from_pointer(@_p.list_if_set!(1))
  :fun ref init_annotations(new_count)
    CapnProto.List.Builder(CapnProto.Meta.Annotation.Builder).from_pointer(@_p.init_list(1, 1, 2, new_count))
  :fun ref trim_annotations(new_start, new_finish)
    CapnProto.List.Builder(CapnProto.Meta.Annotation.Builder).from_pointer(@_p.trim_list(1, 1, 2, new_start, new_finish))

:struct CapnProto.Meta.Superclass.Builder
  :let _p CapnProto.Pointer.Struct.Builder
  :new from_pointer(@_p)
  :fun as_reader: CapnProto.Meta.Superclass.read_from_pointer(@_p.as_reader)

  :const capn_proto_data_word_count U16: 1
  :const capn_proto_pointer_count U16: 1

  :is TraceData
  :fun trace_data(trace TraceData.Observer)
    @as_reader.trace_data(trace)

  :fun id: @_p.u64(0x0)
  :fun id_if_set!: @_p.u64_if_set!(0x0)
  :fun ref "id="(new_value): @_p.set_u64(0x0, new_value, 0)

  :fun ref brand: CapnProto.Meta.Brand.Builder.from_pointer(@_p.struct(0, 0, 1))
  :fun ref brand_if_set!: CapnProto.Meta.Brand.Builder.from_pointer(@_p.struct_if_set!(0, 0, 1))

:struct CapnProto.Meta.Method.Builder
  :let _p CapnProto.Pointer.Struct.Builder
  :new from_pointer(@_p)
  :fun as_reader: CapnProto.Meta.Method.read_from_pointer(@_p.as_reader)

  :const capn_proto_data_word_count U16: 3
  :const capn_proto_pointer_count U16: 5

  :is TraceData
  :fun trace_data(trace TraceData.Observer)
    @as_reader.trace_data(trace)

  :fun ref name: @_p.text(0)
  :fun ref name_if_set!: @_p.text_if_set!(0)
  :fun ref "name="(new_value): @_p.set_text(0, new_value, "")

  :fun code_order: @_p.u16(0x0)
  :fun code_order_if_set!: @_p.u16_if_set!(0x0)
  :fun ref "code_order="(new_value): @_p.set_u16(0x0, new_value, 0)

  :fun param_struct_type: @_p.u64(0x8)
  :fun param_struct_type_if_set!: @_p.u64_if_set!(0x8)
  :fun ref "param_struct_type="(new_value): @_p.set_u64(0x8, new_value, 0)

  :fun result_struct_type: @_p.u64(0x10)
  :fun result_struct_type_if_set!: @_p.u64_if_set!(0x10)
  :fun ref "result_struct_type="(new_value): @_p.set_u64(0x10, new_value, 0)

  :fun ref annotations: CapnProto.List.Builder(CapnProto.Meta.Annotation.Builder).from_pointer(@_p.list(1))
  :fun ref annotations_if_set!: CapnProto.List.Builder(CapnProto.Meta.Annotation.Builder).from_pointer(@_p.list_if_set!(1))
  :fun ref init_annotations(new_count)
    CapnProto.List.Builder(CapnProto.Meta.Annotation.Builder).from_pointer(@_p.init_list(1, 1, 2, new_count))
  :fun ref trim_annotations(new_start, new_finish)
    CapnProto.List.Builder(CapnProto.Meta.Annotation.Builder).from_pointer(@_p.trim_list(1, 1, 2, new_start, new_finish))

  :fun ref param_brand: CapnProto.Meta.Brand.Builder.from_pointer(@_p.struct(2, 0, 1))
  :fun ref param_brand_if_set!: CapnProto.Meta.Brand.Builder.from_pointer(@_p.struct_if_set!(2, 0, 1))

  :fun ref result_brand: CapnProto.Meta.Brand.Builder.from_pointer(@_p.struct(3, 0, 1))
  :fun ref result_brand_if_set!: CapnProto.Meta.Brand.Builder.from_pointer(@_p.struct_if_set!(3, 0, 1))

  :fun ref implicit_parameters: CapnProto.List.Builder(CapnProto.Meta.Node.Parameter.Builder).from_pointer(@_p.list(4))
  :fun ref implicit_parameters_if_set!: CapnProto.List.Builder(CapnProto.Meta.Node.Parameter.Builder).from_pointer(@_p.list_if_set!(4))
  :fun ref init_implicit_parameters(new_count)
    CapnProto.List.Builder(CapnProto.Meta.Node.Parameter.Builder).from_pointer(@_p.init_list(4, 0, 1, new_count))
  :fun ref trim_implicit_parameters(new_start, new_finish)
    CapnProto.List.Builder(CapnProto.Meta.Node.Parameter.Builder).from_pointer(@_p.trim_list(4, 0, 1, new_start, new_finish))

:struct CapnProto.Meta.Type.Builder
  :let _p CapnProto.Pointer.Struct.Builder
  :new from_pointer(@_p)
  :fun as_reader: CapnProto.Meta.Type.read_from_pointer(@_p.as_reader)

  :const capn_proto_data_word_count U16: 3
  :const capn_proto_pointer_count U16: 1

  :is TraceData
  :fun trace_data(trace TraceData.Observer)
    @as_reader.trace_data(trace)

  :fun is_void: @_p.check_union(0x0, 0)
  :fun void!: @_p.assert_union!(0x0, 0), None
  :fun void_if_set!: @_p.assert_union!(0x0, 0), None
  :fun ref init_void
    @_p.mark_union(0x0, 0)
    None

  :fun is_bool: @_p.check_union(0x0, 1)
  :fun bool!: @_p.assert_union!(0x0, 1), None
  :fun bool_if_set!: @_p.assert_union!(0x0, 1), None
  :fun ref init_bool
    @_p.mark_union(0x0, 1)
    None

  :fun is_int8: @_p.check_union(0x0, 2)
  :fun int8!: @_p.assert_union!(0x0, 2), None
  :fun int8_if_set!: @_p.assert_union!(0x0, 2), None
  :fun ref init_int8
    @_p.mark_union(0x0, 2)
    None

  :fun is_int16: @_p.check_union(0x0, 3)
  :fun int16!: @_p.assert_union!(0x0, 3), None
  :fun int16_if_set!: @_p.assert_union!(0x0, 3), None
  :fun ref init_int16
    @_p.mark_union(0x0, 3)
    None

  :fun is_int32: @_p.check_union(0x0, 4)
  :fun int32!: @_p.assert_union!(0x0, 4), None
  :fun int32_if_set!: @_p.assert_union!(0x0, 4), None
  :fun ref init_int32
    @_p.mark_union(0x0, 4)
    None

  :fun is_int64: @_p.check_union(0x0, 5)
  :fun int64!: @_p.assert_union!(0x0, 5), None
  :fun int64_if_set!: @_p.assert_union!(0x0, 5), None
  :fun ref init_int64
    @_p.mark_union(0x0, 5)
    None

  :fun is_uint8: @_p.check_union(0x0, 6)
  :fun uint8!: @_p.assert_union!(0x0, 6), None
  :fun uint8_if_set!: @_p.assert_union!(0x0, 6), None
  :fun ref init_uint8
    @_p.mark_union(0x0, 6)
    None

  :fun is_uint16: @_p.check_union(0x0, 7)
  :fun uint16!: @_p.assert_union!(0x0, 7), None
  :fun uint16_if_set!: @_p.assert_union!(0x0, 7), None
  :fun ref init_uint16
    @_p.mark_union(0x0, 7)
    None

  :fun is_uint32: @_p.check_union(0x0, 8)
  :fun uint32!: @_p.assert_union!(0x0, 8), None
  :fun uint32_if_set!: @_p.assert_union!(0x0, 8), None
  :fun ref init_uint32
    @_p.mark_union(0x0, 8)
    None

  :fun is_uint64: @_p.check_union(0x0, 9)
  :fun uint64!: @_p.assert_union!(0x0, 9), None
  :fun uint64_if_set!: @_p.assert_union!(0x0, 9), None
  :fun ref init_uint64
    @_p.mark_union(0x0, 9)
    None

  :fun is_float32: @_p.check_union(0x0, 10)
  :fun float32!: @_p.assert_union!(0x0, 10), None
  :fun float32_if_set!: @_p.assert_union!(0x0, 10), None
  :fun ref init_float32
    @_p.mark_union(0x0, 10)
    None

  :fun is_float64: @_p.check_union(0x0, 11)
  :fun float64!: @_p.assert_union!(0x0, 11), None
  :fun float64_if_set!: @_p.assert_union!(0x0, 11), None
  :fun ref init_float64
    @_p.mark_union(0x0, 11)
    None

  :fun is_text: @_p.check_union(0x0, 12)
  :fun text!: @_p.assert_union!(0x0, 12), None
  :fun text_if_set!: @_p.assert_union!(0x0, 12), None
  :fun ref init_text
    @_p.mark_union(0x0, 12)
    None

  :fun is_data: @_p.check_union(0x0, 13)
  :fun data!: @_p.assert_union!(0x0, 13), None
  :fun data_if_set!: @_p.assert_union!(0x0, 13), None
  :fun ref init_data
    @_p.mark_union(0x0, 13)
    None

  :fun is_list: @_p.check_union(0x0, 14)
  :fun ref list!: @_p.assert_union!(0x0, 14), CapnProto.Meta.Type.AS_list.Builder.from_pointer(@_p)
  :fun ref list_if_set!: @_p.assert_union!(0x0, 14), CapnProto.Meta.Type.AS_list.Builder.from_pointer(@_p)
  :fun ref init_list
    @_p.clear_pointer(0) // element_type
    @_p.mark_union(0x0, 14)
    CapnProto.Meta.Type.AS_list.Builder.from_pointer(@_p)

  :fun is_enum: @_p.check_union(0x0, 15)
  :fun ref enum!: @_p.assert_union!(0x0, 15), CapnProto.Meta.Type.AS_enum.Builder.from_pointer(@_p)
  :fun ref enum_if_set!: @_p.assert_union!(0x0, 15), CapnProto.Meta.Type.AS_enum.Builder.from_pointer(@_p)
  :fun ref init_enum
    @_p.clear_64(0x8) // type_id
    @_p.clear_pointer(0) // brand
    @_p.mark_union(0x0, 15)
    CapnProto.Meta.Type.AS_enum.Builder.from_pointer(@_p)

  :fun is_struct: @_p.check_union(0x0, 16)
  :fun ref struct!: @_p.assert_union!(0x0, 16), CapnProto.Meta.Type.AS_struct.Builder.from_pointer(@_p)
  :fun ref struct_if_set!: @_p.assert_union!(0x0, 16), CapnProto.Meta.Type.AS_struct.Builder.from_pointer(@_p)
  :fun ref init_struct
    @_p.clear_64(0x8) // type_id
    @_p.clear_pointer(0) // brand
    @_p.mark_union(0x0, 16)
    CapnProto.Meta.Type.AS_struct.Builder.from_pointer(@_p)

  :fun is_interface: @_p.check_union(0x0, 17)
  :fun ref interface!: @_p.assert_union!(0x0, 17), CapnProto.Meta.Type.AS_interface.Builder.from_pointer(@_p)
  :fun ref interface_if_set!: @_p.assert_union!(0x0, 17), CapnProto.Meta.Type.AS_interface.Builder.from_pointer(@_p)
  :fun ref init_interface
    @_p.clear_64(0x8) // type_id
    @_p.clear_pointer(0) // brand
    @_p.mark_union(0x0, 17)
    CapnProto.Meta.Type.AS_interface.Builder.from_pointer(@_p)

  :fun is_any_pointer: @_p.check_union(0x0, 18)
  :fun ref any_pointer!: @_p.assert_union!(0x0, 18), CapnProto.Meta.Type.AS_anyPointer.Builder.from_pointer(@_p)
  :fun ref any_pointer_if_set!: @_p.assert_union!(0x0, 18), CapnProto.Meta.Type.AS_anyPointer.Builder.from_pointer(@_p)
  :fun ref init_any_pointer
    @_p.mark_union(0x0, 18)
    CapnProto.Meta.Type.AS_anyPointer.Builder.from_pointer(@_p)

:struct CapnProto.Meta.Type.AS_list.Builder
  :let _p CapnProto.Pointer.Struct.Builder
  :new from_pointer(@_p)
  :fun as_reader: CapnProto.Meta.Type.AS_list.read_from_pointer(@_p.as_reader)

  :const capn_proto_data_word_count U16: 3
  :const capn_proto_pointer_count U16: 1

  :is TraceData
  :fun trace_data(trace TraceData.Observer)
    @as_reader.trace_data(trace)

  :fun ref element_type: CapnProto.Meta.Type.Builder.from_pointer(@_p.struct(0, 3, 1))
  :fun ref element_type_if_set!: CapnProto.Meta.Type.Builder.from_pointer(@_p.struct_if_set!(0, 3, 1))

:struct CapnProto.Meta.Type.AS_enum.Builder
  :let _p CapnProto.Pointer.Struct.Builder
  :new from_pointer(@_p)
  :fun as_reader: CapnProto.Meta.Type.AS_enum.read_from_pointer(@_p.as_reader)

  :const capn_proto_data_word_count U16: 3
  :const capn_proto_pointer_count U16: 1

  :is TraceData
  :fun trace_data(trace TraceData.Observer)
    @as_reader.trace_data(trace)

  :fun type_id: @_p.u64(0x8)
  :fun type_id_if_set!: @_p.u64_if_set!(0x8)
  :fun ref "type_id="(new_value): @_p.set_u64(0x8, new_value, 0)

  :fun ref brand: CapnProto.Meta.Brand.Builder.from_pointer(@_p.struct(0, 0, 1))
  :fun ref brand_if_set!: CapnProto.Meta.Brand.Builder.from_pointer(@_p.struct_if_set!(0, 0, 1))

:struct CapnProto.Meta.Type.AS_struct.Builder
  :let _p CapnProto.Pointer.Struct.Builder
  :new from_pointer(@_p)
  :fun as_reader: CapnProto.Meta.Type.AS_struct.read_from_pointer(@_p.as_reader)

  :const capn_proto_data_word_count U16: 3
  :const capn_proto_pointer_count U16: 1

  :is TraceData
  :fun trace_data(trace TraceData.Observer)
    @as_reader.trace_data(trace)

  :fun type_id: @_p.u64(0x8)
  :fun type_id_if_set!: @_p.u64_if_set!(0x8)
  :fun ref "type_id="(new_value): @_p.set_u64(0x8, new_value, 0)

  :fun ref brand: CapnProto.Meta.Brand.Builder.from_pointer(@_p.struct(0, 0, 1))
  :fun ref brand_if_set!: CapnProto.Meta.Brand.Builder.from_pointer(@_p.struct_if_set!(0, 0, 1))

:struct CapnProto.Meta.Type.AS_interface.Builder
  :let _p CapnProto.Pointer.Struct.Builder
  :new from_pointer(@_p)
  :fun as_reader: CapnProto.Meta.Type.AS_interface.read_from_pointer(@_p.as_reader)

  :const capn_proto_data_word_count U16: 3
  :const capn_proto_pointer_count U16: 1

  :is TraceData
  :fun trace_data(trace TraceData.Observer)
    @as_reader.trace_data(trace)

  :fun type_id: @_p.u64(0x8)
  :fun type_id_if_set!: @_p.u64_if_set!(0x8)
  :fun ref "type_id="(new_value): @_p.set_u64(0x8, new_value, 0)

  :fun ref brand: CapnProto.Meta.Brand.Builder.from_pointer(@_p.struct(0, 0, 1))
  :fun ref brand_if_set!: CapnProto.Meta.Brand.Builder.from_pointer(@_p.struct_if_set!(0, 0, 1))

:struct CapnProto.Meta.Type.AS_anyPointer.Builder
  :let _p CapnProto.Pointer.Struct.Builder
  :new from_pointer(@_p)
  :fun as_reader: CapnProto.Meta.Type.AS_anyPointer.read_from_pointer(@_p.as_reader)

  :const capn_proto_data_word_count U16: 3
  :const capn_proto_pointer_count U16: 1

  :is TraceData
  :fun trace_data(trace TraceData.Observer)
    @as_reader.trace_data(trace)

  :fun is_unconstrained: @_p.check_union(0x8, 0)
  :fun ref unconstrained!: @_p.assert_union!(0x8, 0), CapnProto.Meta.Type.AS_anyPointer.AS_unconstrained.Builder.from_pointer(@_p)
  :fun ref unconstrained_if_set!: @_p.assert_union!(0x8, 0), CapnProto.Meta.Type.AS_anyPointer.AS_unconstrained.Builder.from_pointer(@_p)
  :fun ref init_unconstrained
    @_p.mark_union(0x8, 0)
    CapnProto.Meta.Type.AS_anyPointer.AS_unconstrained.Builder.from_pointer(@_p)

  :fun is_parameter: @_p.check_union(0x8, 1)
  :fun ref parameter!: @_p.assert_union!(0x8, 1), CapnProto.Meta.Type.AS_anyPointer.AS_parameter.Builder.from_pointer(@_p)
  :fun ref parameter_if_set!: @_p.assert_union!(0x8, 1), CapnProto.Meta.Type.AS_anyPointer.AS_parameter.Builder.from_pointer(@_p)
  :fun ref init_parameter
    @_p.clear_64(0x10) // scope_id
    @_p.clear_16(0xa) // parameter_index
    @_p.mark_union(0x8, 1)
    CapnProto.Meta.Type.AS_anyPointer.AS_parameter.Builder.from_pointer(@_p)

  :fun is_implicit_method_parameter: @_p.check_union(0x8, 2)
  :fun ref implicit_method_parameter!: @_p.assert_union!(0x8, 2), CapnProto.Meta.Type.AS_anyPointer.AS_implicitMethodParameter.Builder.from_pointer(@_p)
  :fun ref implicit_method_parameter_if_set!: @_p.assert_union!(0x8, 2), CapnProto.Meta.Type.AS_anyPointer.AS_implicitMethodParameter.Builder.from_pointer(@_p)
  :fun ref init_implicit_method_parameter
    @_p.clear_16(0xa) // parameter_index
    @_p.mark_union(0x8, 2)
    CapnProto.Meta.Type.AS_anyPointer.AS_implicitMethodParameter.Builder.from_pointer(@_p)

:struct CapnProto.Meta.Type.AS_anyPointer.AS_unconstrained.Builder
  :let _p CapnProto.Pointer.Struct.Builder
  :new from_pointer(@_p)
  :fun as_reader: CapnProto.Meta.Type.AS_anyPointer.AS_unconstrained.read_from_pointer(@_p.as_reader)

  :const capn_proto_data_word_count U16: 3
  :const capn_proto_pointer_count U16: 1

  :is TraceData
  :fun trace_data(trace TraceData.Observer)
    @as_reader.trace_data(trace)

  :fun is_any_kind: @_p.check_union(0xa, 0)
  :fun any_kind!: @_p.assert_union!(0xa, 0), None
  :fun any_kind_if_set!: @_p.assert_union!(0xa, 0), None
  :fun ref init_any_kind
    @_p.mark_union(0xa, 0)
    None

  :fun is_struct: @_p.check_union(0xa, 1)
  :fun struct!: @_p.assert_union!(0xa, 1), None
  :fun struct_if_set!: @_p.assert_union!(0xa, 1), None
  :fun ref init_struct
    @_p.mark_union(0xa, 1)
    None

  :fun is_list: @_p.check_union(0xa, 2)
  :fun list!: @_p.assert_union!(0xa, 2), None
  :fun list_if_set!: @_p.assert_union!(0xa, 2), None
  :fun ref init_list
    @_p.mark_union(0xa, 2)
    None

  :fun is_capability: @_p.check_union(0xa, 3)
  :fun capability!: @_p.assert_union!(0xa, 3), None
  :fun capability_if_set!: @_p.assert_union!(0xa, 3), None
  :fun ref init_capability
    @_p.mark_union(0xa, 3)
    None

:struct CapnProto.Meta.Type.AS_anyPointer.AS_parameter.Builder
  :let _p CapnProto.Pointer.Struct.Builder
  :new from_pointer(@_p)
  :fun as_reader: CapnProto.Meta.Type.AS_anyPointer.AS_parameter.read_from_pointer(@_p.as_reader)

  :const capn_proto_data_word_count U16: 3
  :const capn_proto_pointer_count U16: 1

  :is TraceData
  :fun trace_data(trace TraceData.Observer)
    @as_reader.trace_data(trace)

  :fun scope_id: @_p.u64(0x10)
  :fun scope_id_if_set!: @_p.u64_if_set!(0x10)
  :fun ref "scope_id="(new_value): @_p.set_u64(0x10, new_value, 0)

  :fun parameter_index: @_p.u16(0xa)
  :fun parameter_index_if_set!: @_p.u16_if_set!(0xa)
  :fun ref "parameter_index="(new_value): @_p.set_u16(0xa, new_value, 0)

:struct CapnProto.Meta.Type.AS_anyPointer.AS_implicitMethodParameter.Builder
  :let _p CapnProto.Pointer.Struct.Builder
  :new from_pointer(@_p)
  :fun as_reader: CapnProto.Meta.Type.AS_anyPointer.AS_implicitMethodParameter.read_from_pointer(@_p.as_reader)

  :const capn_proto_data_word_count U16: 3
  :const capn_proto_pointer_count U16: 1

  :is TraceData
  :fun trace_data(trace TraceData.Observer)
    @as_reader.trace_data(trace)

  :fun parameter_index: @_p.u16(0xa)
  :fun parameter_index_if_set!: @_p.u16_if_set!(0xa)
  :fun ref "parameter_index="(new_value): @_p.set_u16(0xa, new_value, 0)

:struct CapnProto.Meta.Brand.Builder
  :let _p CapnProto.Pointer.Struct.Builder
  :new from_pointer(@_p)
  :fun as_reader: CapnProto.Meta.Brand.read_from_pointer(@_p.as_reader)

  :const capn_proto_data_word_count U16: 0
  :const capn_proto_pointer_count U16: 1

  :is TraceData
  :fun trace_data(trace TraceData.Observer)
    @as_reader.trace_data(trace)

  :fun ref scopes: CapnProto.List.Builder(CapnProto.Meta.Brand.Scope.Builder).from_pointer(@_p.list(0))
  :fun ref scopes_if_set!: CapnProto.List.Builder(CapnProto.Meta.Brand.Scope.Builder).from_pointer(@_p.list_if_set!(0))
  :fun ref init_scopes(new_count)
    CapnProto.List.Builder(CapnProto.Meta.Brand.Scope.Builder).from_pointer(@_p.init_list(0, 2, 1, new_count))
  :fun ref trim_scopes(new_start, new_finish)
    CapnProto.List.Builder(CapnProto.Meta.Brand.Scope.Builder).from_pointer(@_p.trim_list(0, 2, 1, new_start, new_finish))

:struct CapnProto.Meta.Brand.Scope.Builder
  :let _p CapnProto.Pointer.Struct.Builder
  :new from_pointer(@_p)
  :fun as_reader: CapnProto.Meta.Brand.Scope.read_from_pointer(@_p.as_reader)

  :const capn_proto_data_word_count U16: 2
  :const capn_proto_pointer_count U16: 1

  :is TraceData
  :fun trace_data(trace TraceData.Observer)
    @as_reader.trace_data(trace)

  :fun scope_id: @_p.u64(0x0)
  :fun scope_id_if_set!: @_p.u64_if_set!(0x0)
  :fun ref "scope_id="(new_value): @_p.set_u64(0x0, new_value, 0)

  :fun is_bind: @_p.check_union(0x8, 0)
  :fun ref bind!: @_p.assert_union!(0x8, 0), CapnProto.List.Builder(CapnProto.Meta.Brand.Binding.Builder).from_pointer(@_p.list(0))
  :fun ref bind_if_set!: @_p.assert_union!(0x8, 0), CapnProto.List.Builder(CapnProto.Meta.Brand.Binding.Builder).from_pointer(@_p.list_if_set!(0))
  :fun ref init_bind(new_count)
    @_p.mark_union(0x8, 0)
    CapnProto.List.Builder(CapnProto.Meta.Brand.Binding.Builder).from_pointer(@_p.init_list(0, 1, 1, new_count))

  :fun is_inherit: @_p.check_union(0x8, 1)
  :fun inherit!: @_p.assert_union!(0x8, 1), None
  :fun inherit_if_set!: @_p.assert_union!(0x8, 1), None
  :fun ref init_inherit
    @_p.mark_union(0x8, 1)
    None

:struct CapnProto.Meta.Brand.Binding.Builder
  :let _p CapnProto.Pointer.Struct.Builder
  :new from_pointer(@_p)
  :fun as_reader: CapnProto.Meta.Brand.Binding.read_from_pointer(@_p.as_reader)

  :const capn_proto_data_word_count U16: 1
  :const capn_proto_pointer_count U16: 1

  :is TraceData
  :fun trace_data(trace TraceData.Observer)
    @as_reader.trace_data(trace)

  :fun is_unbound: @_p.check_union(0x0, 0)
  :fun unbound!: @_p.assert_union!(0x0, 0), None
  :fun unbound_if_set!: @_p.assert_union!(0x0, 0), None
  :fun ref init_unbound
    @_p.mark_union(0x0, 0)
    None

  :fun is_type: @_p.check_union(0x0, 1)
  :fun ref type!: @_p.assert_union!(0x0, 1), CapnProto.Meta.Type.Builder.from_pointer(@_p.struct(0, 3, 1))
  :fun ref type_if_set!: @_p.assert_union!(0x0, 1), CapnProto.Meta.Type.Builder.from_pointer(@_p.struct_if_set!(0, 3, 1))
  :fun ref init_type
    @_p.clear_pointer(0) // type
    @_p.mark_union(0x0, 1)
    CapnProto.Meta.Type.Builder.from_pointer(@_p.struct(0, 3, 1))

:struct CapnProto.Meta.Value.Builder
  :let _p CapnProto.Pointer.Struct.Builder
  :new from_pointer(@_p)
  :fun as_reader: CapnProto.Meta.Value.read_from_pointer(@_p.as_reader)

  :const capn_proto_data_word_count U16: 2
  :const capn_proto_pointer_count U16: 1

  :is TraceData
  :fun trace_data(trace TraceData.Observer)
    @as_reader.trace_data(trace)

  :fun is_void: @_p.check_union(0x0, 0)
  :fun void!: @_p.assert_union!(0x0, 0), None
  :fun void_if_set!: @_p.assert_union!(0x0, 0), None
  :fun ref init_void
    @_p.mark_union(0x0, 0)
    None

  :fun is_bool: @_p.check_union(0x0, 1)
  :fun bool!: @_p.assert_union!(0x0, 1), @_p.bool(0x2, 0b00000001)
  :fun bool_if_set!: @_p.assert_union!(0x0, 1), @_p.bool_if_set!(0x2, 0b00000001)
  :fun ref init_bool(new_value)
    @_p.set_bool(0x2, 0b00000001, Bool[new_value])
    @_p.mark_union(0x0, 1)
    @_p.bool(0x2, 0b00000001)

  :fun is_int8: @_p.check_union(0x0, 2)
  :fun int8!: @_p.assert_union!(0x0, 2), @_p.i8(0x2)
  :fun int8_if_set!: @_p.assert_union!(0x0, 2), @_p.i8_if_set!(0x2)
  :fun ref init_int8(new_value)
    @_p.set_i8(0x2, new_value, 0)
    @_p.mark_union(0x0, 2)
    @_p.i8(0x2)

  :fun is_int16: @_p.check_union(0x0, 3)
  :fun int16!: @_p.assert_union!(0x0, 3), @_p.i16(0x2)
  :fun int16_if_set!: @_p.assert_union!(0x0, 3), @_p.i16_if_set!(0x2)
  :fun ref init_int16(new_value)
    @_p.set_i16(0x2, new_value, 0)
    @_p.mark_union(0x0, 3)
    @_p.i16(0x2)

  :fun is_int32: @_p.check_union(0x0, 4)
  :fun int32!: @_p.assert_union!(0x0, 4), @_p.i32(0x4)
  :fun int32_if_set!: @_p.assert_union!(0x0, 4), @_p.i32_if_set!(0x4)
  :fun ref init_int32(new_value)
    @_p.set_i32(0x4, new_value, 0)
    @_p.mark_union(0x0, 4)
    @_p.i32(0x4)

  :fun is_int64: @_p.check_union(0x0, 5)
  :fun int64!: @_p.assert_union!(0x0, 5), @_p.i64(0x8)
  :fun int64_if_set!: @_p.assert_union!(0x0, 5), @_p.i64_if_set!(0x8)
  :fun ref init_int64(new_value)
    @_p.set_i64(0x8, new_value, 0)
    @_p.mark_union(0x0, 5)
    @_p.i64(0x8)

  :fun is_uint8: @_p.check_union(0x0, 6)
  :fun uint8!: @_p.assert_union!(0x0, 6), @_p.u8(0x2)
  :fun uint8_if_set!: @_p.assert_union!(0x0, 6), @_p.u8_if_set!(0x2)
  :fun ref init_uint8(new_value)
    @_p.set_u8(0x2, new_value, 0)
    @_p.mark_union(0x0, 6)
    @_p.u8(0x2)

  :fun is_uint16: @_p.check_union(0x0, 7)
  :fun uint16!: @_p.assert_union!(0x0, 7), @_p.u16(0x2)
  :fun uint16_if_set!: @_p.assert_union!(0x0, 7), @_p.u16_if_set!(0x2)
  :fun ref init_uint16(new_value)
    @_p.set_u16(0x2, new_value, 0)
    @_p.mark_union(0x0, 7)
    @_p.u16(0x2)

  :fun is_uint32: @_p.check_union(0x0, 8)
  :fun uint32!: @_p.assert_union!(0x0, 8), @_p.u32(0x4)
  :fun uint32_if_set!: @_p.assert_union!(0x0, 8), @_p.u32_if_set!(0x4)
  :fun ref init_uint32(new_value)
    @_p.set_u32(0x4, new_value, 0)
    @_p.mark_union(0x0, 8)
    @_p.u32(0x4)

  :fun is_uint64: @_p.check_union(0x0, 9)
  :fun uint64!: @_p.assert_union!(0x0, 9), @_p.u64(0x8)
  :fun uint64_if_set!: @_p.assert_union!(0x0, 9), @_p.u64_if_set!(0x8)
  :fun ref init_uint64(new_value)
    @_p.set_u64(0x8, new_value, 0)
    @_p.mark_union(0x0, 9)
    @_p.u64(0x8)

  :fun is_float32: @_p.check_union(0x0, 10)
  :fun float32!: @_p.assert_union!(0x0, 10), @_p.f32(0x4)
  :fun float32_if_set!: @_p.assert_union!(0x0, 10), @_p.f32_if_set!(0x4)
  :fun ref init_float32(new_value)
    @_p.set_f32(0x4, new_value, 0.0)
    @_p.mark_union(0x0, 10)
    @_p.f32(0x4)

  :fun is_float64: @_p.check_union(0x0, 11)
  :fun float64!: @_p.assert_union!(0x0, 11), @_p.f64(0x8)
  :fun float64_if_set!: @_p.assert_union!(0x0, 11), @_p.f64_if_set!(0x8)
  :fun ref init_float64(new_value)
    @_p.set_f64(0x8, new_value, 0.0)
    @_p.mark_union(0x0, 11)
    @_p.f64(0x8)

  :fun is_text: @_p.check_union(0x0, 12)
  :fun ref text!: @_p.assert_union!(0x0, 12), @_p.text(0)
  :fun ref text_if_set!: @_p.assert_union!(0x0, 12), @_p.text_if_set!(0)
  :fun ref init_text(new_value)
    @_p.set_text(0, new_value, "")
    @_p.mark_union(0x0, 12)
    @_p.text(0)

  :fun is_data: @_p.check_union(0x0, 13)
  :fun ref data!: @_p.assert_union!(0x0, 13), @_p.data(0)
  :fun ref data_if_set!: @_p.assert_union!(0x0, 13), @_p.data_if_set!(0)
  :fun ref init_data(new_value)
    @_p.set_data(0, new_value, b"")
    @_p.mark_union(0x0, 13)
    @_p.data(0)

  :fun is_list: @_p.check_union(0x0, 14)
  :fun ref list!: @_p.assert_union!(0x0, 14), None // UNHANDLED: anyPointer
  :fun ref list_if_set!: @_p.assert_union!(0x0, 14), None // UNHANDLED: anyPointer
  :fun ref init_list(new_value None)
    @_p.mark_union(0x0, 14)
    None // UNHANDLED: anyPointer

  :fun is_enum: @_p.check_union(0x0, 15)
  :fun enum!: @_p.assert_union!(0x0, 15), @_p.u16(0x2)
  :fun enum_if_set!: @_p.assert_union!(0x0, 15), @_p.u16_if_set!(0x2)
  :fun ref init_enum(new_value)
    @_p.set_u16(0x2, new_value, 0)
    @_p.mark_union(0x0, 15)
    @_p.u16(0x2)

  :fun is_struct: @_p.check_union(0x0, 16)
  :fun ref struct!: @_p.assert_union!(0x0, 16), None // UNHANDLED: anyPointer
  :fun ref struct_if_set!: @_p.assert_union!(0x0, 16), None // UNHANDLED: anyPointer
  :fun ref init_struct(new_value None)
    @_p.mark_union(0x0, 16)
    None // UNHANDLED: anyPointer

  :fun is_interface: @_p.check_union(0x0, 17)
  :fun interface!: @_p.assert_union!(0x0, 17), None
  :fun interface_if_set!: @_p.assert_union!(0x0, 17), None
  :fun ref init_interface
    @_p.mark_union(0x0, 17)
    None

  :fun is_any_pointer: @_p.check_union(0x0, 18)
  :fun ref any_pointer!: @_p.assert_union!(0x0, 18), None // UNHANDLED: anyPointer
  :fun ref any_pointer_if_set!: @_p.assert_union!(0x0, 18), None // UNHANDLED: anyPointer
  :fun ref init_any_pointer(new_value None)
    @_p.mark_union(0x0, 18)
    None // UNHANDLED: anyPointer

:struct CapnProto.Meta.Annotation.Builder
  :let _p CapnProto.Pointer.Struct.Builder
  :new from_pointer(@_p)
  :fun as_reader: CapnProto.Meta.Annotation.read_from_pointer(@_p.as_reader)

  :const capn_proto_data_word_count U16: 1
  :const capn_proto_pointer_count U16: 2

  :is TraceData
  :fun trace_data(trace TraceData.Observer)
    @as_reader.trace_data(trace)

  :fun id: @_p.u64(0x0)
  :fun id_if_set!: @_p.u64_if_set!(0x0)
  :fun ref "id="(new_value): @_p.set_u64(0x0, new_value, 0)

  :fun ref value: CapnProto.Meta.Value.Builder.from_pointer(@_p.struct(0, 2, 1))
  :fun ref value_if_set!: CapnProto.Meta.Value.Builder.from_pointer(@_p.struct_if_set!(0, 2, 1))

  :fun ref brand: CapnProto.Meta.Brand.Builder.from_pointer(@_p.struct(1, 0, 1))
  :fun ref brand_if_set!: CapnProto.Meta.Brand.Builder.from_pointer(@_p.struct_if_set!(1, 0, 1))

:struct CapnProto.Meta.CodeGeneratorRequest.Builder
  :let _p CapnProto.Pointer.Struct.Builder
  :new from_pointer(@_p)
  :fun as_reader: CapnProto.Meta.CodeGeneratorRequest.read_from_pointer(@_p.as_reader)

  :const capn_proto_data_word_count U16: 0
  :const capn_proto_pointer_count U16: 2

  :is TraceData
  :fun trace_data(trace TraceData.Observer)
    @as_reader.trace_data(trace)

  :fun ref nodes: CapnProto.List.Builder(CapnProto.Meta.Node.Builder).from_pointer(@_p.list(0))
  :fun ref nodes_if_set!: CapnProto.List.Builder(CapnProto.Meta.Node.Builder).from_pointer(@_p.list_if_set!(0))
  :fun ref init_nodes(new_count)
    CapnProto.List.Builder(CapnProto.Meta.Node.Builder).from_pointer(@_p.init_list(0, 5, 6, new_count))
  :fun ref trim_nodes(new_start, new_finish)
    CapnProto.List.Builder(CapnProto.Meta.Node.Builder).from_pointer(@_p.trim_list(0, 5, 6, new_start, new_finish))

  :fun ref requested_files: CapnProto.List.Builder(CapnProto.Meta.CodeGeneratorRequest.RequestedFile.Builder).from_pointer(@_p.list(1))
  :fun ref requested_files_if_set!: CapnProto.List.Builder(CapnProto.Meta.CodeGeneratorRequest.RequestedFile.Builder).from_pointer(@_p.list_if_set!(1))
  :fun ref init_requested_files(new_count)
    CapnProto.List.Builder(CapnProto.Meta.CodeGeneratorRequest.RequestedFile.Builder).from_pointer(@_p.init_list(1, 1, 2, new_count))
  :fun ref trim_requested_files(new_start, new_finish)
    CapnProto.List.Builder(CapnProto.Meta.CodeGeneratorRequest.RequestedFile.Builder).from_pointer(@_p.trim_list(1, 1, 2, new_start, new_finish))

:struct CapnProto.Meta.CodeGeneratorRequest.RequestedFile.Builder
  :let _p CapnProto.Pointer.Struct.Builder
  :new from_pointer(@_p)
  :fun as_reader: CapnProto.Meta.CodeGeneratorRequest.RequestedFile.read_from_pointer(@_p.as_reader)

  :const capn_proto_data_word_count U16: 1
  :const capn_proto_pointer_count U16: 2

  :is TraceData
  :fun trace_data(trace TraceData.Observer)
    @as_reader.trace_data(trace)

  :fun id: @_p.u64(0x0)
  :fun id_if_set!: @_p.u64_if_set!(0x0)
  :fun ref "id="(new_value): @_p.set_u64(0x0, new_value, 0)

  :fun ref filename: @_p.text(0)
  :fun ref filename_if_set!: @_p.text_if_set!(0)
  :fun ref "filename="(new_value): @_p.set_text(0, new_value, "")

  :fun ref imports: CapnProto.List.Builder(CapnProto.Meta.CodeGeneratorRequest.RequestedFile.Import.Builder).from_pointer(@_p.list(1))
  :fun ref imports_if_set!: CapnProto.List.Builder(CapnProto.Meta.CodeGeneratorRequest.RequestedFile.Import.Builder).from_pointer(@_p.list_if_set!(1))
  :fun ref init_imports(new_count)
    CapnProto.List.Builder(CapnProto.Meta.CodeGeneratorRequest.RequestedFile.Import.Builder).from_pointer(@_p.init_list(1, 1, 1, new_count))
  :fun ref trim_imports(new_start, new_finish)
    CapnProto.List.Builder(CapnProto.Meta.CodeGeneratorRequest.RequestedFile.Import.Builder).from_pointer(@_p.trim_list(1, 1, 1, new_start, new_finish))

:struct CapnProto.Meta.CodeGeneratorRequest.RequestedFile.Import.Builder
  :let _p CapnProto.Pointer.Struct.Builder
  :new from_pointer(@_p)
  :fun as_reader: CapnProto.Meta.CodeGeneratorRequest.RequestedFile.Import.read_from_pointer(@_p.as_reader)

  :const capn_proto_data_word_count U16: 1
  :const capn_proto_pointer_count U16: 1

  :is TraceData
  :fun trace_data(trace TraceData.Observer)
    @as_reader.trace_data(trace)

  :fun id: @_p.u64(0x0)
  :fun id_if_set!: @_p.u64_if_set!(0x0)
  :fun ref "id="(new_value): @_p.set_u64(0x0, new_value, 0)

  :fun ref name: @_p.text(0)
  :fun ref name_if_set!: @_p.text_if_set!(0)
  :fun ref "name="(new_value): @_p.set_text(0, new_value, "")
