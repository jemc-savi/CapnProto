///
// NOTE: This file was auto-generated from a Cap'n Proto file
// using the `capnp` compiler with the `--output=savi` option.

:struct CapnProto.Meta.Node
  :let _p CapnProto.Pointer.Struct
  :new from_pointer(@_p)

  :fun id: @_p.u64(0x0)
  :fun ref "id="(new_value U64): @_p.set_u64(0x0, new_value)

  :fun ref display_name: @_p.text(0)

  :fun display_name_prefix_length: @_p.u32(0x8)
  :fun ref "display_name_prefix_length="(new_value U32): @_p.set_u32(0x8, new_value)

  :fun scope_id: @_p.u64(0x10)
  :fun ref "scope_id="(new_value U64): @_p.set_u64(0x10, new_value)

  :fun ref nested_nodes: CapnProto.List(CapnProto.Meta.Node.NestedNode).new(@_p.list(1))

  :fun ref annotations: CapnProto.List(CapnProto.Meta.Annotation).new(@_p.list(2))

  :fun is_file: @_p.check_union(0xc, 0)
  :fun file!: @_p.assert_union!(0xc, 0), None

  :fun is_struct: @_p.check_union(0xc, 1)
  :fun ref struct!: @_p.assert_union!(0xc, 1), CapnProto.Meta.Node.AS_struct.from_pointer(@_p)

  :fun is_enum: @_p.check_union(0xc, 2)
  :fun ref enum!: @_p.assert_union!(0xc, 2), CapnProto.Meta.Node.AS_enum.from_pointer(@_p)

  :fun is_interface: @_p.check_union(0xc, 3)
  :fun ref interface!: @_p.assert_union!(0xc, 3), CapnProto.Meta.Node.AS_interface.from_pointer(@_p)

  :fun is_const: @_p.check_union(0xc, 4)
  :fun ref const!: @_p.assert_union!(0xc, 4), CapnProto.Meta.Node.AS_const.from_pointer(@_p)

  :fun is_annotation: @_p.check_union(0xc, 5)
  :fun ref annotation!: @_p.assert_union!(0xc, 5), CapnProto.Meta.Node.AS_annotation.from_pointer(@_p)

  :fun ref parameters: CapnProto.List(CapnProto.Meta.Node.Parameter).new(@_p.list(5))

  :fun is_generic: @_p.bool(0x24, 0b00000001)
  :fun ref "is_generic="(new_value Bool): @_p.set_bool(0x24, 0b00000001, new_value)

:struct CapnProto.Meta.Node.AS_struct
  :let _p CapnProto.Pointer.Struct
  :new from_pointer(@_p)

  :fun data_word_count: @_p.u16(0xe)
  :fun ref "data_word_count="(new_value U16): @_p.set_u16(0xe, new_value)

  :fun pointer_count: @_p.u16(0x18)
  :fun ref "pointer_count="(new_value U16): @_p.set_u16(0x18, new_value)

  :fun preferred_list_encoding: CapnProto.Meta.ElementSize._new(@_p.u16(0x1a))
  :fun ref "preferred_list_encoding="(new_value CapnProto.Meta.ElementSize): @_p.set_u16(0x1a, new_value.u16)

  :fun is_group: @_p.bool(0x1c, 0b00000001)
  :fun ref "is_group="(new_value Bool): @_p.set_bool(0x1c, 0b00000001, new_value)

  :fun discriminant_count: @_p.u16(0x1e)
  :fun ref "discriminant_count="(new_value U16): @_p.set_u16(0x1e, new_value)

  :fun discriminant_offset: @_p.u32(0x20)
  :fun ref "discriminant_offset="(new_value U32): @_p.set_u32(0x20, new_value)

  :fun ref fields: CapnProto.List(CapnProto.Meta.Field).new(@_p.list(3))

:struct CapnProto.Meta.Node.AS_enum
  :let _p CapnProto.Pointer.Struct
  :new from_pointer(@_p)

  :fun ref enumerants: CapnProto.List(CapnProto.Meta.Enumerant).new(@_p.list(3))

:struct CapnProto.Meta.Node.AS_interface
  :let _p CapnProto.Pointer.Struct
  :new from_pointer(@_p)

  :fun ref methods: CapnProto.List(CapnProto.Meta.Method).new(@_p.list(3))

  :fun ref superclasses: CapnProto.List(CapnProto.Meta.Superclass).new(@_p.list(4))

:struct CapnProto.Meta.Node.AS_const
  :let _p CapnProto.Pointer.Struct
  :new from_pointer(@_p)

  :fun ref type: CapnProto.Meta.Type.from_pointer(@_p.struct(3))

  :fun ref value: CapnProto.Meta.Value.from_pointer(@_p.struct(4))

:struct CapnProto.Meta.Node.AS_annotation
  :let _p CapnProto.Pointer.Struct
  :new from_pointer(@_p)

  :fun ref type: CapnProto.Meta.Type.from_pointer(@_p.struct(3))

  :fun targets_file: @_p.bool(0xe, 0b00000001)
  :fun ref "targets_file="(new_value Bool): @_p.set_bool(0xe, 0b00000001, new_value)

  :fun targets_const: @_p.bool(0xe, 0b00000010)
  :fun ref "targets_const="(new_value Bool): @_p.set_bool(0xe, 0b00000010, new_value)

  :fun targets_enum: @_p.bool(0xe, 0b00000100)
  :fun ref "targets_enum="(new_value Bool): @_p.set_bool(0xe, 0b00000100, new_value)

  :fun targets_enumerant: @_p.bool(0xe, 0b00001000)
  :fun ref "targets_enumerant="(new_value Bool): @_p.set_bool(0xe, 0b00001000, new_value)

  :fun targets_struct: @_p.bool(0xe, 0b00010000)
  :fun ref "targets_struct="(new_value Bool): @_p.set_bool(0xe, 0b00010000, new_value)

  :fun targets_field: @_p.bool(0xe, 0b00100000)
  :fun ref "targets_field="(new_value Bool): @_p.set_bool(0xe, 0b00100000, new_value)

  :fun targets_union: @_p.bool(0xe, 0b01000000)
  :fun ref "targets_union="(new_value Bool): @_p.set_bool(0xe, 0b01000000, new_value)

  :fun targets_group: @_p.bool(0xe, 0b10000000)
  :fun ref "targets_group="(new_value Bool): @_p.set_bool(0xe, 0b10000000, new_value)

  :fun targets_interface: @_p.bool(0xf, 0b00000001)
  :fun ref "targets_interface="(new_value Bool): @_p.set_bool(0xf, 0b00000001, new_value)

  :fun targets_method: @_p.bool(0xf, 0b00000010)
  :fun ref "targets_method="(new_value Bool): @_p.set_bool(0xf, 0b00000010, new_value)

  :fun targets_param: @_p.bool(0xf, 0b00000100)
  :fun ref "targets_param="(new_value Bool): @_p.set_bool(0xf, 0b00000100, new_value)

  :fun targets_annotation: @_p.bool(0xf, 0b00001000)
  :fun ref "targets_annotation="(new_value Bool): @_p.set_bool(0xf, 0b00001000, new_value)

:struct CapnProto.Meta.Node.Parameter
  :let _p CapnProto.Pointer.Struct
  :new from_pointer(@_p)

  :fun ref name: @_p.text(0)

:struct CapnProto.Meta.Node.NestedNode
  :let _p CapnProto.Pointer.Struct
  :new from_pointer(@_p)

  :fun ref name: @_p.text(0)

  :fun id: @_p.u64(0x0)
  :fun ref "id="(new_value U64): @_p.set_u64(0x0, new_value)

:struct CapnProto.Meta.Field
  :let _p CapnProto.Pointer.Struct
  :new from_pointer(@_p)

  :const no_discriminant U16: 65535

  :fun ref name: @_p.text(0)

  :fun code_order: @_p.u16(0x0)
  :fun ref "code_order="(new_value U16): @_p.set_u16(0x0, new_value)

  :fun ref annotations: CapnProto.List(CapnProto.Meta.Annotation).new(@_p.list(1))

  :fun discriminant_value: @_p.u16(0x2).bit_xor(65535)
  :fun ref "discriminant_value="(new_value U16): @_p.set_u16(0x2, new_value.bit_xor(65535))

  :fun is_slot: @_p.check_union(0x8, 0)
  :fun ref slot!: @_p.assert_union!(0x8, 0), CapnProto.Meta.Field.AS_slot.from_pointer(@_p)

  :fun is_group: @_p.check_union(0x8, 1)
  :fun ref group!: @_p.assert_union!(0x8, 1), CapnProto.Meta.Field.AS_group.from_pointer(@_p)

  :fun ref ordinal: CapnProto.Meta.Field.AS_ordinal.from_pointer(@_p)

:struct CapnProto.Meta.Field.AS_slot
  :let _p CapnProto.Pointer.Struct
  :new from_pointer(@_p)

  :fun offset: @_p.u32(0x4)
  :fun ref "offset="(new_value U32): @_p.set_u32(0x4, new_value)

  :fun ref type: CapnProto.Meta.Type.from_pointer(@_p.struct(2))

  :fun ref default_value: CapnProto.Meta.Value.from_pointer(@_p.struct(3))

  :fun had_explicit_default: @_p.bool(0x10, 0b00000001)
  :fun ref "had_explicit_default="(new_value Bool): @_p.set_bool(0x10, 0b00000001, new_value)

:struct CapnProto.Meta.Field.AS_group
  :let _p CapnProto.Pointer.Struct
  :new from_pointer(@_p)

  :fun type_id: @_p.u64(0x10)
  :fun ref "type_id="(new_value U64): @_p.set_u64(0x10, new_value)

:struct CapnProto.Meta.Field.AS_ordinal
  :let _p CapnProto.Pointer.Struct
  :new from_pointer(@_p)

  :fun is_implicit: @_p.check_union(0xa, 0)
  :fun implicit!: @_p.assert_union!(0xa, 0), None

  :fun is_explicit: @_p.check_union(0xa, 1)
  :fun explicit!: @_p.assert_union!(0xa, 1), @_p.u16(0xc)

:struct CapnProto.Meta.Enumerant
  :let _p CapnProto.Pointer.Struct
  :new from_pointer(@_p)

  :fun ref name: @_p.text(0)

  :fun code_order: @_p.u16(0x0)
  :fun ref "code_order="(new_value U16): @_p.set_u16(0x0, new_value)

  :fun ref annotations: CapnProto.List(CapnProto.Meta.Annotation).new(@_p.list(1))

:struct CapnProto.Meta.Superclass
  :let _p CapnProto.Pointer.Struct
  :new from_pointer(@_p)

  :fun id: @_p.u64(0x0)
  :fun ref "id="(new_value U64): @_p.set_u64(0x0, new_value)

  :fun ref brand: CapnProto.Meta.Brand.from_pointer(@_p.struct(0))

:struct CapnProto.Meta.Method
  :let _p CapnProto.Pointer.Struct
  :new from_pointer(@_p)

  :fun ref name: @_p.text(0)

  :fun code_order: @_p.u16(0x0)
  :fun ref "code_order="(new_value U16): @_p.set_u16(0x0, new_value)

  :fun param_struct_type: @_p.u64(0x8)
  :fun ref "param_struct_type="(new_value U64): @_p.set_u64(0x8, new_value)

  :fun result_struct_type: @_p.u64(0x10)
  :fun ref "result_struct_type="(new_value U64): @_p.set_u64(0x10, new_value)

  :fun ref annotations: CapnProto.List(CapnProto.Meta.Annotation).new(@_p.list(1))

  :fun ref param_brand: CapnProto.Meta.Brand.from_pointer(@_p.struct(2))

  :fun ref result_brand: CapnProto.Meta.Brand.from_pointer(@_p.struct(3))

  :fun ref implicit_parameters: CapnProto.List(CapnProto.Meta.Node.Parameter).new(@_p.list(4))

:struct CapnProto.Meta.Type
  :let _p CapnProto.Pointer.Struct
  :new from_pointer(@_p)

  :fun is_void: @_p.check_union(0x0, 0)
  :fun void!: @_p.assert_union!(0x0, 0), None

  :fun is_bool: @_p.check_union(0x0, 1)
  :fun bool!: @_p.assert_union!(0x0, 1), None

  :fun is_int8: @_p.check_union(0x0, 2)
  :fun int8!: @_p.assert_union!(0x0, 2), None

  :fun is_int16: @_p.check_union(0x0, 3)
  :fun int16!: @_p.assert_union!(0x0, 3), None

  :fun is_int32: @_p.check_union(0x0, 4)
  :fun int32!: @_p.assert_union!(0x0, 4), None

  :fun is_int64: @_p.check_union(0x0, 5)
  :fun int64!: @_p.assert_union!(0x0, 5), None

  :fun is_uint8: @_p.check_union(0x0, 6)
  :fun uint8!: @_p.assert_union!(0x0, 6), None

  :fun is_uint16: @_p.check_union(0x0, 7)
  :fun uint16!: @_p.assert_union!(0x0, 7), None

  :fun is_uint32: @_p.check_union(0x0, 8)
  :fun uint32!: @_p.assert_union!(0x0, 8), None

  :fun is_uint64: @_p.check_union(0x0, 9)
  :fun uint64!: @_p.assert_union!(0x0, 9), None

  :fun is_float32: @_p.check_union(0x0, 10)
  :fun float32!: @_p.assert_union!(0x0, 10), None

  :fun is_float64: @_p.check_union(0x0, 11)
  :fun float64!: @_p.assert_union!(0x0, 11), None

  :fun is_text: @_p.check_union(0x0, 12)
  :fun text!: @_p.assert_union!(0x0, 12), None

  :fun is_data: @_p.check_union(0x0, 13)
  :fun data!: @_p.assert_union!(0x0, 13), None

  :fun is_list: @_p.check_union(0x0, 14)
  :fun ref list!: @_p.assert_union!(0x0, 14), CapnProto.Meta.Type.AS_list.from_pointer(@_p)

  :fun is_enum: @_p.check_union(0x0, 15)
  :fun ref enum!: @_p.assert_union!(0x0, 15), CapnProto.Meta.Type.AS_enum.from_pointer(@_p)

  :fun is_struct: @_p.check_union(0x0, 16)
  :fun ref struct!: @_p.assert_union!(0x0, 16), CapnProto.Meta.Type.AS_struct.from_pointer(@_p)

  :fun is_interface: @_p.check_union(0x0, 17)
  :fun ref interface!: @_p.assert_union!(0x0, 17), CapnProto.Meta.Type.AS_interface.from_pointer(@_p)

  :fun is_any_pointer: @_p.check_union(0x0, 18)
  :fun ref any_pointer!: @_p.assert_union!(0x0, 18), CapnProto.Meta.Type.AS_anyPointer.from_pointer(@_p)

:struct CapnProto.Meta.Type.AS_list
  :let _p CapnProto.Pointer.Struct
  :new from_pointer(@_p)

  :fun ref element_type: CapnProto.Meta.Type.from_pointer(@_p.struct(0))

:struct CapnProto.Meta.Type.AS_enum
  :let _p CapnProto.Pointer.Struct
  :new from_pointer(@_p)

  :fun type_id: @_p.u64(0x8)
  :fun ref "type_id="(new_value U64): @_p.set_u64(0x8, new_value)

  :fun ref brand: CapnProto.Meta.Brand.from_pointer(@_p.struct(0))

:struct CapnProto.Meta.Type.AS_struct
  :let _p CapnProto.Pointer.Struct
  :new from_pointer(@_p)

  :fun type_id: @_p.u64(0x8)
  :fun ref "type_id="(new_value U64): @_p.set_u64(0x8, new_value)

  :fun ref brand: CapnProto.Meta.Brand.from_pointer(@_p.struct(0))

:struct CapnProto.Meta.Type.AS_interface
  :let _p CapnProto.Pointer.Struct
  :new from_pointer(@_p)

  :fun type_id: @_p.u64(0x8)
  :fun ref "type_id="(new_value U64): @_p.set_u64(0x8, new_value)

  :fun ref brand: CapnProto.Meta.Brand.from_pointer(@_p.struct(0))

:struct CapnProto.Meta.Type.AS_anyPointer
  :let _p CapnProto.Pointer.Struct
  :new from_pointer(@_p)

  :fun is_unconstrained: @_p.check_union(0x8, 0)
  :fun ref unconstrained!: @_p.assert_union!(0x8, 0), CapnProto.Meta.Type.AS_anyPointer.AS_unconstrained.from_pointer(@_p)

  :fun is_parameter: @_p.check_union(0x8, 1)
  :fun ref parameter!: @_p.assert_union!(0x8, 1), CapnProto.Meta.Type.AS_anyPointer.AS_parameter.from_pointer(@_p)

  :fun is_implicit_method_parameter: @_p.check_union(0x8, 2)
  :fun ref implicit_method_parameter!: @_p.assert_union!(0x8, 2), CapnProto.Meta.Type.AS_anyPointer.AS_implicitMethodParameter.from_pointer(@_p)

:struct CapnProto.Meta.Type.AS_anyPointer.AS_unconstrained
  :let _p CapnProto.Pointer.Struct
  :new from_pointer(@_p)

  :fun is_any_kind: @_p.check_union(0xa, 0)
  :fun any_kind!: @_p.assert_union!(0xa, 0), None

  :fun is_struct: @_p.check_union(0xa, 1)
  :fun struct!: @_p.assert_union!(0xa, 1), None

  :fun is_list: @_p.check_union(0xa, 2)
  :fun list!: @_p.assert_union!(0xa, 2), None

  :fun is_capability: @_p.check_union(0xa, 3)
  :fun capability!: @_p.assert_union!(0xa, 3), None

:struct CapnProto.Meta.Type.AS_anyPointer.AS_parameter
  :let _p CapnProto.Pointer.Struct
  :new from_pointer(@_p)

  :fun scope_id: @_p.u64(0x10)
  :fun ref "scope_id="(new_value U64): @_p.set_u64(0x10, new_value)

  :fun parameter_index: @_p.u16(0xa)
  :fun ref "parameter_index="(new_value U16): @_p.set_u16(0xa, new_value)

:struct CapnProto.Meta.Type.AS_anyPointer.AS_implicitMethodParameter
  :let _p CapnProto.Pointer.Struct
  :new from_pointer(@_p)

  :fun parameter_index: @_p.u16(0xa)
  :fun ref "parameter_index="(new_value U16): @_p.set_u16(0xa, new_value)

:struct CapnProto.Meta.Brand
  :let _p CapnProto.Pointer.Struct
  :new from_pointer(@_p)

  :fun ref scopes: CapnProto.List(CapnProto.Meta.Brand.Scope).new(@_p.list(0))

:struct CapnProto.Meta.Brand.Scope
  :let _p CapnProto.Pointer.Struct
  :new from_pointer(@_p)

  :fun scope_id: @_p.u64(0x0)
  :fun ref "scope_id="(new_value U64): @_p.set_u64(0x0, new_value)

  :fun is_bind: @_p.check_union(0x8, 0)
  :fun ref bind!: @_p.assert_union!(0x8, 0), CapnProto.List(CapnProto.Meta.Brand.Binding).new(@_p.list(0))

  :fun is_inherit: @_p.check_union(0x8, 1)
  :fun inherit!: @_p.assert_union!(0x8, 1), None

:struct CapnProto.Meta.Brand.Binding
  :let _p CapnProto.Pointer.Struct
  :new from_pointer(@_p)

  :fun is_unbound: @_p.check_union(0x0, 0)
  :fun unbound!: @_p.assert_union!(0x0, 0), None

  :fun is_type: @_p.check_union(0x0, 1)
  :fun ref type!: @_p.assert_union!(0x0, 1), CapnProto.Meta.Type.from_pointer(@_p.struct(0))

:struct CapnProto.Meta.Value
  :let _p CapnProto.Pointer.Struct
  :new from_pointer(@_p)

  :fun is_void: @_p.check_union(0x0, 0)
  :fun void!: @_p.assert_union!(0x0, 0), None

  :fun is_bool: @_p.check_union(0x0, 1)
  :fun bool!: @_p.assert_union!(0x0, 1), @_p.bool(0x2, 0b00000001)

  :fun is_int8: @_p.check_union(0x0, 2)
  :fun int8!: @_p.assert_union!(0x0, 2), @_p.i8(0x2)

  :fun is_int16: @_p.check_union(0x0, 3)
  :fun int16!: @_p.assert_union!(0x0, 3), @_p.i16(0x2)

  :fun is_int32: @_p.check_union(0x0, 4)
  :fun int32!: @_p.assert_union!(0x0, 4), @_p.i32(0x4)

  :fun is_int64: @_p.check_union(0x0, 5)
  :fun int64!: @_p.assert_union!(0x0, 5), @_p.i64(0x8)

  :fun is_uint8: @_p.check_union(0x0, 6)
  :fun uint8!: @_p.assert_union!(0x0, 6), @_p.u8(0x2)

  :fun is_uint16: @_p.check_union(0x0, 7)
  :fun uint16!: @_p.assert_union!(0x0, 7), @_p.u16(0x2)

  :fun is_uint32: @_p.check_union(0x0, 8)
  :fun uint32!: @_p.assert_union!(0x0, 8), @_p.u32(0x4)

  :fun is_uint64: @_p.check_union(0x0, 9)
  :fun uint64!: @_p.assert_union!(0x0, 9), @_p.u64(0x8)

  :fun is_float32: @_p.check_union(0x0, 10)
  :fun float32!: @_p.assert_union!(0x0, 10), @_p.f32(0x4)

  :fun is_float64: @_p.check_union(0x0, 11)
  :fun float64!: @_p.assert_union!(0x0, 11), @_p.f64(0x8)

  :fun is_text: @_p.check_union(0x0, 12)
  :fun ref text!: @_p.assert_union!(0x0, 12), @_p.text(0)

  :fun is_data: @_p.check_union(0x0, 13)
  :fun ref data!: @_p.assert_union!(0x0, 13), @_p.data(0)

  :fun is_list: @_p.check_union(0x0, 14)
  :fun ref list!: @_p.assert_union!(0x0, 14), None // UNHANDLED: anyPointer

  :fun is_enum: @_p.check_union(0x0, 15)
  :fun enum!: @_p.assert_union!(0x0, 15), @_p.u16(0x2)

  :fun is_struct: @_p.check_union(0x0, 16)
  :fun ref struct!: @_p.assert_union!(0x0, 16), None // UNHANDLED: anyPointer

  :fun is_interface: @_p.check_union(0x0, 17)
  :fun interface!: @_p.assert_union!(0x0, 17), None

  :fun is_any_pointer: @_p.check_union(0x0, 18)
  :fun ref any_pointer!: @_p.assert_union!(0x0, 18), None // UNHANDLED: anyPointer

:struct CapnProto.Meta.Annotation
  :let _p CapnProto.Pointer.Struct
  :new from_pointer(@_p)

  :fun id: @_p.u64(0x0)
  :fun ref "id="(new_value U64): @_p.set_u64(0x0, new_value)

  :fun ref value: CapnProto.Meta.Value.from_pointer(@_p.struct(0))

  :fun ref brand: CapnProto.Meta.Brand.from_pointer(@_p.struct(1))

:enum CapnProto.Meta.ElementSize
  :bit_width 16

  :member Empty 0
  :member Bit 1
  :member Byte 2
  :member TwoBytes 3
  :member FourBytes 4
  :member EightBytes 5
  :member Pointer 6
  :member InlineComposite 7

  :fun non _new(u16 U16)
    try (
      @from_u64!(u16.u64)
    |
      CapnProto.Meta.ElementSize.Empty
    )

:struct CapnProto.Meta.CodeGeneratorRequest
  :let _p CapnProto.Pointer.Struct
  :new from_pointer(@_p)

  :fun ref nodes: CapnProto.List(CapnProto.Meta.Node).new(@_p.list(0))

  :fun ref requested_files: CapnProto.List(CapnProto.Meta.CodeGeneratorRequest.RequestedFile).new(@_p.list(1))

:struct CapnProto.Meta.CodeGeneratorRequest.RequestedFile
  :let _p CapnProto.Pointer.Struct
  :new from_pointer(@_p)

  :fun id: @_p.u64(0x0)
  :fun ref "id="(new_value U64): @_p.set_u64(0x0, new_value)

  :fun ref filename: @_p.text(0)

  :fun ref imports: CapnProto.List(CapnProto.Meta.CodeGeneratorRequest.RequestedFile.Import).new(@_p.list(1))

:struct CapnProto.Meta.CodeGeneratorRequest.RequestedFile.Import
  :let _p CapnProto.Pointer.Struct
  :new from_pointer(@_p)

  :fun id: @_p.u64(0x0)
  :fun ref "id="(new_value U64): @_p.set_u64(0x0, new_value)

  :fun ref name: @_p.text(0)
