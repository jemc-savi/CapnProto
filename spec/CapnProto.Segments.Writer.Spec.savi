:class CapnProto.Segments.Writer.Spec
  :is Spec
  :const describes: "CapnProto.Segments.Writer"

  :it "writes an odd number of segments with no header padding"
    segments = [
      b"\
        \x11\x11\x11\x11\x11\x11\x11\x11\
        \x22\x22\x22\x22\x22\x22\x22\x22\
        \x33\x33\x33\x33\x33\x33\x33\x33\
      "
      b"\
        \x44\x44\x44\x44\x44\x44\x44\x44\
        \x55\x55\x55\x55\x55\x55\x55\x55\
        \x66\x66\x66\x66\x66\x66\x66\x66\
        \x77\x77\x77\x77\x77\x77\x77\x77\
      "
      b"\
        \x88\x88\x88\x88\x88\x88\x88\x88\
        \x99\x99\x99\x99\x99\x99\x99\x99\
        \xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\
        \xbb\xbb\xbb\xbb\xbb\xbb\xbb\xbb\
        \xcc\xcc\xcc\xcc\xcc\xcc\xcc\xcc\
      "
    ]

    output Array(Bytes)'val = try (
      CapnProto.Segments.Writer.add_header_to_val_buffers!(segments)
    |
      []
    )
    assert: output == [
      b"\
        \x02\x00\x00\x00\
        \x03\x00\x00\x00\
        \x04\x00\x00\x00\
        \x05\x00\x00\x00\
      "
      b"\
        \x11\x11\x11\x11\x11\x11\x11\x11\
        \x22\x22\x22\x22\x22\x22\x22\x22\
        \x33\x33\x33\x33\x33\x33\x33\x33\
      "
      b"\
        \x44\x44\x44\x44\x44\x44\x44\x44\
        \x55\x55\x55\x55\x55\x55\x55\x55\
        \x66\x66\x66\x66\x66\x66\x66\x66\
        \x77\x77\x77\x77\x77\x77\x77\x77\
      "
      b"\
        \x88\x88\x88\x88\x88\x88\x88\x88\
        \x99\x99\x99\x99\x99\x99\x99\x99\
        \xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\
        \xbb\xbb\xbb\xbb\xbb\xbb\xbb\xbb\
        \xcc\xcc\xcc\xcc\xcc\xcc\xcc\xcc\
      "
    ]

    reader = CapnProto.Segments.Reader.new
    stream = ByteStream.Reader.new
    write_stream = ByteStream.Writer.to_reader(stream)

    output.each -> (buffer | write_stream << buffer)
    assert no_error: write_stream.flush!

    assert: reader.read!(stream) == True
    assert: reader.take_segments.take_val_buffers == segments

  :it "writes an even number of segments with header padding"
    segments = [
      b"\
        \x11\x11\x11\x11\x11\x11\x11\x11\
        \x22\x22\x22\x22\x22\x22\x22\x22\
        \x33\x33\x33\x33\x33\x33\x33\x33\
      "
      b"\
        \x44\x44\x44\x44\x44\x44\x44\x44\
        \x55\x55\x55\x55\x55\x55\x55\x55\
        \x66\x66\x66\x66\x66\x66\x66\x66\
        \x77\x77\x77\x77\x77\x77\x77\x77\
      "
      b"\
        \x88\x88\x88\x88\x88\x88\x88\x88\
        \x99\x99\x99\x99\x99\x99\x99\x99\
        \xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\
        \xbb\xbb\xbb\xbb\xbb\xbb\xbb\xbb\
        \xcc\xcc\xcc\xcc\xcc\xcc\xcc\xcc\
      "
      b"\
        \xdd\xdd\xdd\xdd\xdd\xdd\xdd\xdd\
        \xee\xee\xee\xee\xee\xee\xee\xee\
        \xff\xff\xff\xff\xff\xff\xff\xff\
      "
    ]

    output Array(Bytes)'val = try (
      CapnProto.Segments.Writer.add_header_to_val_buffers!(segments)
    |
      []
    )
    assert: output == [
      b"\
        \x03\x00\x00\x00\
        \x03\x00\x00\x00\
        \x04\x00\x00\x00\
        \x05\x00\x00\x00\
        \x03\x00\x00\x00\
        \x00\x00\x00\x00\
      "
      b"\
        \x11\x11\x11\x11\x11\x11\x11\x11\
        \x22\x22\x22\x22\x22\x22\x22\x22\
        \x33\x33\x33\x33\x33\x33\x33\x33\
      "
      b"\
        \x44\x44\x44\x44\x44\x44\x44\x44\
        \x55\x55\x55\x55\x55\x55\x55\x55\
        \x66\x66\x66\x66\x66\x66\x66\x66\
        \x77\x77\x77\x77\x77\x77\x77\x77\
      "
      b"\
        \x88\x88\x88\x88\x88\x88\x88\x88\
        \x99\x99\x99\x99\x99\x99\x99\x99\
        \xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\
        \xbb\xbb\xbb\xbb\xbb\xbb\xbb\xbb\
        \xcc\xcc\xcc\xcc\xcc\xcc\xcc\xcc\
      "
      b"\
        \xdd\xdd\xdd\xdd\xdd\xdd\xdd\xdd\
        \xee\xee\xee\xee\xee\xee\xee\xee\
        \xff\xff\xff\xff\xff\xff\xff\xff\
      "
    ]

    reader = CapnProto.Segments.Reader.new
    stream = ByteStream.Reader.new
    write_stream = ByteStream.Writer.to_reader(stream)

    output.each -> (buffer | write_stream << buffer)
    assert no_error: write_stream.flush!

    assert: reader.read!(stream) == True
    assert: reader.take_segments.take_val_buffers == segments
